/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parse_redir.c                               :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fflamion <fflamion@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/01 18:12:45 by fflamion          #+#    #+#             */
/*   Updated: 2024/11/05 10:16:10 by fflamion         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minishell.h"

int	is_valid_redir_argument(t_token *token)
{
	return (token && (token->type == TOKEN_ARGUMENT
			|| token->type == TOKEN_HEREDOC
			|| token->type == TOKEN_STRING
			|| token->prev->type == TOKEN_ARGUMENT));
}

int	is_redirection_token(t_token *token)
{
	return (token && (token->type == TOKEN_REDIRECTION_IN
			|| token->type == TOKEN_REDIRECTION_OUT
			|| token->type == TOKEN_APPEND || token->type == TOKEN_HEREDOC));
}

t_ast_node	*handle_redirection(t_token **curr_tok, t_sh *shell)
{
	t_ast_node	*redir_node;
	t_token		*token;

	token = *curr_tok;
	*curr_tok = (*curr_tok)->next;
	if (!*curr_tok || !is_valid_redir_argument(*curr_tok))
	{
		if (*curr_tok)
			printf("minishell: %s: Aucun fichier ou dossier de ce type\n",
				(*curr_tok)->value);
		else
			printf("minishell: Aucun fichier ou dossier de ce type\n");
		shell->exit_status = 1;
		return (NULL);
	}
	if (token->type == TOKEN_REDIRECTION_IN)
		redir_node = create_ast_node(AST_REDIRECTION_IN, shell);
	else if (token->type == TOKEN_REDIRECTION_OUT)
		redir_node = create_ast_node(AST_REDIRECTION_OUT, shell);
	else if (token->type == TOKEN_APPEND)
		redir_node = create_ast_node(AST_REDIRECTION_APPEND, shell);
	else
		redir_node = create_ast_node(AST_REDIRECTION_HEREDOC, shell);
	return (redir_node);
}

void	parse_redir(t_token **curr_tok, t_ast_node *cmd_node, t_sh *shell)
{
	t_ast_node	*redir_node;
	t_ast_node	*tmp;

	while (is_redirection_token(*curr_tok))
	{
		redir_node = handle_redirection(curr_tok, shell);
		if (!redir_node)
			return ;
		redir_node->filename = ft_strdup((*curr_tok)->value);
		*curr_tok = (*curr_tok)->next;
		if (!cmd_node->left)
			cmd_node->left = redir_node;
		else
		{
			tmp = cmd_node->left;
			while (tmp->left)
				tmp = tmp->left;
			tmp->left = redir_node;
		}
	}
}

// void	parse_redir(t_token **curr_tok, t_ast_node *cmd_node, t_sh *shell)
// {
// 	t_token		*token;
// 	t_ast_node	*redir_node;
// 	t_ast_node	*tmp;

// 	while (is_redirection_token(*curr_tok))
// 	{
// 		token = *curr_tok;
// 		*curr_tok = (*curr_tok)->next;
// 		if (!*curr_tok || ((*curr_tok)->type != TOKEN_ARGUMENT
// 				&& (*curr_tok)->type != TOKEN_HEREDOC
// 				&& (*curr_tok)->type != TOKEN_STRING
// 				&& (*curr_tok)->prev->type != TOKEN_ARGUMENT))
// 		{
// 			if (*curr_tok != NULL)
// 				printf("minishell: %s: Aucun fichier ou dossier de ce type\n",
// 					(*curr_tok)->value);
// 			else
// 				printf("minishell: Aucun fichier ou dossier de ce type\n");
// 			// TODO: je ne sais pas si on garde cette erreur
// 			shell->exit_status = 1;
// 			return ;
// 		}
// 		if (token->type == TOKEN_REDIRECTION_IN)
// 			redir_node = create_ast_node(AST_REDIRECTION_IN, shell);
// 		if (token->type == TOKEN_REDIRECTION_OUT)
// 			redir_node = create_ast_node(AST_REDIRECTION_OUT, shell);
// 		else if (token->type == TOKEN_APPEND)
// 			redir_node = create_ast_node(AST_REDIRECTION_APPEND, shell);
// 		else if (token->type == TOKEN_HEREDOC)
// 			redir_node = create_ast_node(AST_REDIRECTION_HEREDOC, shell);
// 		redir_node->filename = ft_strdup((*curr_tok)->value);
// 		*curr_tok = (*curr_tok)->next;
// 		if (!cmd_node->left)
// 			cmd_node->left = redir_node;
// 		else
// 		{
// 			tmp = cmd_node->left;
// 			while (tmp->left)
// 				tmp = tmp->left;
// 			tmp->left = redir_node;
// 		}
// 	}
// }
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parser.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fflamion <fflamion@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/01 18:12:45 by fflamion          #+#    #+#             */
/*   Updated: 2024/11/10 14:13:21 by fflamion         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minishell.h"

t_ast_node	*ast_parser(t_t_list *token_list, t_sh *shell)
{
	t_token		*current_token;
	t_ast_node	*ast_root;

	current_token = token_list->first;
	ast_root = parse_and_or_sequence(&current_token, shell);
	return (ast_root);
}

t_ast_node	*parse_and_or_sequence(t_token **current_token, t_sh *shell)
{
	t_ast_node	*left;
	t_ast_node	*node;
	t_token		*token;

	left = parse_pipeline(current_token, shell);
	while (*current_token && ((*current_token)->type == TOKEN_AND
			|| (*current_token)->type == TOKEN_OR))
	{
		token = *current_token;
		*current_token = (*current_token)->next;
		node = create_ast_node(AST_AND, shell);
		if (token->type == TOKEN_OR)
		{
			node->type = AST_OR;
		}
		node->left = left;
		node->right = parse_pipeline(current_token, shell);
		left = node;
	}
	return (left);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ast_list.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fflamion <fflamion@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/01 18:12:42 by fflamion          #+#    #+#             */
/*   Updated: 2024/11/12 15:13:49 by fflamion         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minishell.h"

t_ast_node	*create_ast_node(t_ast_node_type type, t_sh *shell)
{
	t_ast_node	*node;

	node = malloc(sizeof(t_ast_node));
	if (!node)
		return (NULL);
	node->type = type;
	node->argv = NULL;
	node->filename = NULL;
	node->left = NULL;
	node->right = NULL;
	node->shell = shell;
	return (node);
}

char	**duplicate_argv(char **argv, int argc, char *argument)
{
	char	**new_argv;
	int		i;

	new_argv = malloc(sizeof(char *) * (argc + 2));
	if (!new_argv)
		return (NULL);
	i = 0;
	while (i < argc)
	{
		new_argv[i] = argv[i];
		i++;
	}
	new_argv[i] = ft_strdup(argument);
	new_argv[i + 1] = NULL;
	return (new_argv);
}

void	add_argument(t_ast_node *node, char *argument)
{
	char	**new_argv;
	int		argc;

	argc = 0;
	while (node->argv && node->argv[argc])
		argc++;
	new_argv = duplicate_argv(node->argv, argc, argument);
	if (!new_argv)
		return ;
	free(node->argv);
	node->argv = new_argv;
}

void	free_ast(t_ast_node *node)
{
	int	i;

	if (!node)
		return ;
	if (node->argv)
	{
		i = 0;
		while (node->argv[i])
		{
			free(node->argv[i]);
			i++;
		}
		free(node->argv);
	}
	if (node->filename)
		free(node->filename);
	free_ast(node->left);
	free_ast(node->right);
	free(node);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parse_pipeline.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fflamion <fflamion@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/01 18:12:45 by fflamion          #+#    #+#             */
/*   Updated: 2024/11/12 00:30:44 by fflamion         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minishell.h"

t_ast_node	*parse_parentheses(t_token **current_token, t_sh *shell)
{
	t_ast_node	*node;
	char		*token_value;

	if ((*current_token)->type == TOKEN_LPAREN)
	{
		*current_token = (*current_token)->next;
		node = parse_and_or_sequence(current_token, shell);
		if (!(*current_token) || (*current_token)->type != TOKEN_RPAREN)
		{
			if (*current_token)
				token_value = (*current_token)->value;
			else
				token_value = "newline";
			fprintf(stderr,
				"minishell: syntax error near unexpected token `%s'\n",
				token_value);
			return (NULL);
		}
		*current_token = (*current_token)->next;
		return (node);
	}
	return (parse_command(current_token, shell));
}

t_ast_node	*parse_pipeline(t_token **current_token, t_sh *shell)
{
	t_ast_node	*left;
	t_ast_node	*node;

	left = parse_parentheses(current_token, shell);
	while (*current_token && (*current_token)->type == TOKEN_PIPE)
	{
		*current_token = (*current_token)->next;
		node = create_ast_node(AST_PIPE, shell);
		node->left = left;
		node->right = parse_parentheses(current_token, shell);
		left = node;
	}
	return (left);
}

t_ast_node	*parse_command(t_token **current_token, t_sh *shell)
{
	t_ast_node	*node;

	node = create_ast_node(AST_COMMAND, shell);
	if ((*current_token)->type == TOKEN_HEREDOC)
	{
		add_argument(node, "");
	}
	while (*current_token && is_redirection_token(*current_token))
	{
		parse_redir(current_token, node, shell);
	}
	while (*current_token && ((*current_token)->type == TOKEN_COMMAND
			|| (*current_token)->type == TOKEN_ARGUMENT
			|| (*current_token)->type == TOKEN_STRING
			|| (*current_token)->type == TOKEN_EXPAND))
	{
		add_argument(node, (*current_token)->value);
		*current_token = (*current_token)->next;
	}
	while (*current_token && is_redirection_token(*current_token))
	{
		parse_redir(current_token, node, shell);
	}
	return (node);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   free.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fflamion <fflamion@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/06 22:22:16 by fflamion          #+#    #+#             */
/*   Updated: 2024/11/12 15:20:03 by fflamion         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minishell.h"

void	free_shell(t_sh *shell)
{
	size_t	i;

	i = 0;
	while (i < shell->env_size)
	{
		free(shell->env[i].title);
		free(shell->env[i].value);
		i++;
	}
	free(shell->env);
	i = -1;
	while (shell->envp[++i])
		free(shell->envp[i]);
	free(shell->envp);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   fun.c                                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fflamion <fflamion@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/05 06:29:51 by fflamion          #+#    #+#             */
/*   Updated: 2024/11/12 00:21:12 by fflamion         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minishell.h"

// void	init_colors(t_colors *color_set)
// {
// 	color_set->colors[0] = "\033[0;31m";
// 	color_set->colors[1] = "\033[1;31m";
// 	color_set->colors[2] = "\033[0;32m";
// 	color_set->colors[3] = "\033[1;32m";
// 	color_set->colors[4] = "\033[0;33m";
// 	color_set->colors[5] = "\033[1;33m";
// 	color_set->colors[6] = "\033[0;34m";
// 	color_set->colors[7] = "\033[1;34m";
// 	color_set->colors[8] = "\033[0;35m";
// 	color_set->colors[9] = "\033[1;35m";
// 	color_set->colors[10] = "\033[0;36m";
// 	color_set->colors[11] = "\033[1;36m";
// 	color_set->colors[12] = "\033[0;37m";
// 	color_set->colors[13] = "\033[1;37m";
// 	color_set->colors[14] = "\033[0;90m";
// 	color_set->colors[15] = "\033[1;90m";
// 	color_set->reset_color = "\033[0m";
// 	color_set->color_count = 16;
// 	color_set->index = 0;
// }
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   initShell.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fflamion <fflamion@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/26 10:23:12 by fflamion          #+#    #+#             */
/*   Updated: 2024/11/12 15:20:03 by fflamion         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minishell.h"

void	create_base_env(t_sh *shell)
{
	shell->env = malloc(sizeof(t_var) * 4);
	if (!shell->env)
		return ;
	shell->env[0].title = ft_strdup("PWD");
	shell->env[0].value = getcwd(NULL, 0);
	shell->env[1].title = ft_strdup("SHLVL");
	shell->env[1].value = ft_strdup("1");
	shell->env[2].title = ft_strdup("_");
	shell->env[2].value = ft_strdup("/usr/bin/env");
	shell->env[3].title = NULL;
	shell->env[3].value = NULL;
	shell->env_size = 4;
	return ;
}

void	parse_env(t_sh *shell, char **envp)
{
	char	*buffer;
	int		before_equal;
	size_t	i;
	size_t	y;

	i = 0;
	y = 0;
	while (envp[i++])
		;
	shell->env = malloc(sizeof(t_var) * (i + 1));
	shell->env_size = i;
	i = 0;
	while (envp[y])
	{
		before_equal = ft_strchr(envp[y], '=') - envp[y];
		buffer = malloc(before_equal + 1);
		ft_strlcpy(buffer, envp[y], before_equal + 1);
		shell->env[i].title = ft_strdup(buffer);
		shell->env[i].value = ft_strdup(envp[y] + before_equal + 1);
		y++;
		i++;
		free(buffer);
	}
	shell->env[i].title = NULL;
	shell->env[i].value = NULL;
}

void	initialize_shell(t_sh *shell, char **envp)
{
	if (!*envp)
		create_base_env(shell);
	else
		parse_env(shell, envp);
	shell->envp = ret_env_array(shell);
	shell->exit_status = 0;
}

void	update_exit_status(t_sh *shell, int status)
{
	if (WIFEXITED(status))
		shell->exit_status = WEXITSTATUS(status);
	else
		shell->exit_status = 1;
}

char	*get_env_value(t_sh *shell, char *var_name)
{
	size_t	i;

	i = 0;
	while (i < shell->env_size - 1)
	{
		if (!ft_strcmp(var_name, shell->env[i].title))
			return (shell->env[i].value);
		i++;
	}
	return (NULL);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   shell_utils.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fflamion <fflamion@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/11 13:29:33 by fflamion          #+#    #+#             */
/*   Updated: 2024/11/12 15:21:00 by fflamion         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minishell.h"

char	**populate_arr(t_sh *shell, char **env_arr)
{
	size_t	i;
	size_t	y;
	size_t	z;

	i = 0;
	while (i < shell->env_size - 1)
	{
		y = 0;
		z = 0;
		env_arr[i] = malloc(ft_strlen(shell->env[i].title) + \
			ft_strlen(shell->env[i].value) + 2);
		while (shell->env[i].title[z])
			env_arr[i][y++] = shell->env[i].title[z++];
		env_arr[i][y++] = '=';
		z = 0;
		while (shell->env[i].value[z])
			env_arr[i][y++] = shell->env[i].value[z++];
		env_arr[i][y] = 0;
		i++;
	}
	return (env_arr);
}

char	**ret_env_array(t_sh *shell)
{
	char	**env_arr;

	env_arr = malloc(sizeof(char *) * (shell->env_size));
	if (!env_arr)
		return (NULL);
	env_arr = ft_memset(env_arr, 0, sizeof(char *) * (shell->env_size));
	env_arr = populate_arr(shell, env_arr);
	return (env_arr);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   lexer_list.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fflamion <fflamion@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/12 15:17:50 by fflamion          #+#    #+#             */
/*   Updated: 2024/11/12 15:18:44 by fflamion         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minishell.h"

t_t_list	*init_t_list(void)
{
	t_t_list	*new_t_list;

	new_t_list = malloc(sizeof(t_t_list));
	if (!new_t_list)
		return (NULL);
	new_t_list->first = NULL;
	new_t_list->last = NULL;
	new_t_list->size = 0;
	return (new_t_list);
}

void	free_token_list(t_t_list *t_list_to_free)
{
	t_token	*token_cursor;
	t_token	*to_free;

	if (t_list_to_free)
	{
		token_cursor = t_list_to_free->first;
		while (token_cursor)
		{
			to_free = token_cursor;
			token_cursor = to_free->next;
			if (to_free->value)
				free(to_free->value);
			free(to_free);
		}
		free(t_list_to_free);
	}
}

t_token	*create_token(const char *value, t_token_type type)
{
	t_token	*new_token;

	new_token = malloc(sizeof(t_token));
	if (!new_token)
		return (NULL);
	new_token->next = NULL;
	new_token->prev = NULL;
	new_token->type = type;
	new_token->index = 0;
	new_token->value = ft_strdup(value);
	if (!new_token->value)
	{
		free(new_token);
		return (NULL);
	}
	return (new_token);
}

void	add_token(t_t_list *t_list, t_token *new_token)
{
	if (!t_list || !new_token)
		return ;
	if (!t_list->first)
	{
		new_token->index = 0;
		t_list->first = new_token;
		t_list->last = new_token;
	}
	else
	{
		new_token->index = t_list->last->index + 1;
		new_token->prev = t_list->last;
		new_token->next = NULL;
		t_list->last->next = new_token;
		t_list->last = new_token;
	}
	t_list->size++;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils4.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fflamion <fflamion@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/29 15:54:03 by fflamion          #+#    #+#             */
/*   Updated: 2024/10/31 11:50:58 by fflamion         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minishell.h"

void	handle_heredoc(t_token *heredoc_token, char *delimiter)
{
	int		fd;
	char	*line;

	fd = open("heredoc.txt", O_CREAT | O_WRONLY | O_TRUNC, 0644);
	if (fd == -1)
		return ;
	while (1)
	{
		line = readline("> ");
		if (!line || ft_strcmp(line, delimiter) == 0)
			break ;
		write(fd, line, ft_strlen(line));
		write(fd, "\n", 1);
		free(line);
	}
	free(line);
	close(fd);
	free(heredoc_token->value);
	heredoc_token->value = ft_strdup("heredoc.txt");
}

void	handle_inconnu(char *input, uint16_t *i, t_t_list *t_list)
{
	char	buffer[2];

	buffer[0] = input[*i];
	buffer[1] = '\0';
	add_token(t_list, create_token(buffer, TOKEN_INCONNU));
	(*i)++;
}

void	handle_builtin_command(char *input, uint16_t *i, t_t_list *t_list)
{
	char	buffer[256];
	int		j;

	j = 0;
	while (input[*i] && !ft_isspace(input[*i])
		&& input[*i] != '|' && input[*i] != '>'
		&& input[*i] != '<' && j < (int) sizeof(buffer) - 1)
	{
		buffer[j++] = input[(*i)++];
	}
	buffer[j] = '\0';
	add_token(t_list, create_token(buffer, TOKEN_COMMAND));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils1.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fflamion <fflamion@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/24 17:04:19 by fflamion          #+#    #+#             */
/*   Updated: 2024/11/11 04:03:16 by fflamion         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minishell.h"

void	h_pipe(char *input, uint16_t *i, t_t_list *t_list)
{
	if (input[*i + 1] == '|')
	{
		add_token(t_list, create_token("||", TOKEN_OR));
		(*i) += 2;
	}
	else
	{
		add_token(t_list, create_token("|", TOKEN_PIPE));
		(*i)++;
	}
}

void	h_rout(char *input, uint16_t *i, t_t_list *t_list)
{
	if (input[*i + 1] == '>')
	{
		add_token(t_list, create_token(">>", TOKEN_APPEND));
		(*i) += 2;
	}
	else
	{
		add_token(t_list, create_token(">", TOKEN_REDIRECTION_OUT));
		(*i)++;
	}
}

void	h_rin(char *input, uint16_t *i, t_t_list *t_list)
{
	char	buffer[256];
	int		j;

	if (input[*i + 1] == '<')
	{
		add_token(t_list, create_token("<<", TOKEN_HEREDOC));
		(*i) += 2;
		while (input[*i] && ft_isspace(input[*i]))
			(*i)++;
		j = 0;
		while (input[*i] && !ft_isspace(input[*i]) && j < 255)
			buffer[j++] = input[(*i)++];
		buffer[j] = '\0';
		if (j > 0)
			add_token(t_list, create_token(buffer, TOKEN_STRING));
	}
	else
	{
		add_token(t_list, create_token("<", TOKEN_REDIRECTION_IN));
		(*i)++;
	}
}

void	h_s_q(char *input, uint16_t *i, t_t_list *t_list)
{
	char		buffer[256];
	uint16_t	j;

	j = 0;
	(*i)++;
	while (input[*i] && input[*i] != '\'' && j < sizeof(buffer) - 1)
		buffer[j++] = input[(*i)++];
	buffer[j] = '\0';
	if (input[*i] == '\'')
	{
		add_token(t_list, create_token(buffer, TOKEN_STRING));
		(*i)++;
	}
	else
		fprintf(stderr, "Error: Missing closing single quote\n");
}

// void	h_d_q(char *input, uint16_t *i, t_t_list *t_list, t_sh *shell)
// {
// 	char	buffer[256];
// 	char	*env_value;
// 	size_t	j;

// 	j = 0;
// 	(*i)++;
// 	while (input[*i] && input[*i] != '\"')
// 	{
// 		if (input[*i] == '$' && input[*i + 1] == '?')
// 		{
// 			(*i) += 2;
// 			env_value = ft_itoa(shell->exit_status);
// 			while (*env_value && j < sizeof(buffer) - 1)
// 				buffer[j++] = *env_value++;
// 		}
// 		else if (input[*i] == '$')
// 		{
// 			(*i)++;
// 			env_value = parse_env_var(input, i, shell);
// 			while (*env_value && j < sizeof(buffer) - 1)
// 				buffer[j++] = *env_value++;
// 		}
// 		else if (j < sizeof(buffer) - 1)
// 			buffer[j++] = input[(*i)++];
// 	}
// 	buffer[j] = '\0';
// 	add_token(t_list, create_token(buffer, TOKEN_STRING));
// 	if (input[*i] == '\"')
// 		(*i)++;
// 	else
// 		printf("Error: Missing closing double quote\n");
// }
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   lexer.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fflamion <fflamion@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/12 15:18:59 by fflamion          #+#    #+#             */
/*   Updated: 2024/11/12 15:19:02 by fflamion         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minishell.h"

int	is_builtin_command(char *cmd)
{
	return (!ft_strcmp(cmd, "cd") || !ft_strcmp(cmd, "history")
		|| !ft_strcmp(cmd, "exit") || !ft_strcmp(cmd, "alias")
		|| !ft_strcmp(cmd, "export") || !ft_strcmp(cmd, "unset"));
}

bool	is_whitespace(char c, uint16_t *i)
{
	if (ft_isspace(c))
	{
		(*i)++;
		return (true);
	}
	return (false);
}

void	handle_token(char *input, uint16_t *i, t_t_list *t_list, t_sh *shell)
{
	if (input[*i] == '|')
		h_pipe(input, i, t_list);
	else if (input[*i] == '>')
		h_rout(input, i, t_list);
	else if (input[*i] == '<')
		h_rin(input, i, t_list);
	else if (input[*i] == '\'')
		h_s_q(input, i, t_list);
	else if (input[*i] == '\"')
		h_d_q(input, i, t_list, shell);
	else if (input[*i] == '&' && input[*i + 1] == '&')
		handle_and(i, t_list);
	else if (input[*i] == '*')
		handle_wildcards(i, t_list);
	else if (input[*i] == '$')
		h_exp(input, i, t_list, shell);
	else if (input[*i] == '(' || input[*i] == ')')
		h_par(input[*i], i, t_list);
	else if (ft_strchr("!@#%^&_=", input[*i]))
		handle_inconnu(input, i, t_list);
	else if (is_builtin_command(&input[*i]))
		handle_builtin_command(input, i, t_list);
	else
		h_cmd_arg(input, i, t_list, shell);
}

t_t_list	*lexer(char *input, t_sh *shell)
{
	t_t_list	*t_list;
	uint16_t	i;

	i = 0;
	t_list = init_t_list();
	if (!t_list)
		return (NULL);
	while (input[i] && is_whitespace(input[i], &i))
		;
	if (input[i] == '\0')
		return (t_list);
	i = 0;
	while (input[i])
	{
		while (is_whitespace(input[i], &i))
			;
		if (input[i] == '\0')
			break ;
		handle_token(input, &i, t_list, shell);
	}
	return (t_list);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils3.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fflamion <fflamion@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/08 13:34:12 by fflamion          #+#    #+#             */
/*   Updated: 2024/11/12 15:20:03 by fflamion         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minishell.h"

void	handle_brace_expand(char *input, uint16_t *i, t_t_list *t_list)
{
	char	buffer[256];
	size_t	j;
	char	*word;

	j = 0;
	(*i)++;
	while (input[*i] && input[*i] != '}')
	{
		if (j < sizeof(buffer) - 1)
			buffer[j++] = input[*i];
		(*i)++;
	}
	if (input[*i] != '}')
	{
		fprintf(stderr, "Error: Missing closing brace\n");
		return ;
	}
	(*i)++;
	buffer[j] = '\0';
	word = ft_strtok(buffer, " ");
	while (word != NULL)
	{
		add_token(t_list, create_token(word, TOKEN_EXPAND));
		word = ft_strtok(NULL, " ");
	}
}

void	h_alnum_ex(char *input, uint16_t *i, t_t_list *token_list, t_sh *shell)
{
	char			buffer[256];
	unsigned int	j;
	char			*value;

	j = 0;
	while (input[*i] && (ft_isalnum(input[*i]) || input[*i] == '_'))
	{
		if (j < sizeof(buffer) - 1)
			buffer[j++] = input[*i];
		(*i)++;
	}
	buffer[j] = '\0';
	value = get_env_value(shell, buffer);
	if (value)
		add_token(token_list, create_token((value), TOKEN_EXPAND));
	else
		add_token(token_list, create_token((""), TOKEN_EXPAND));
}

void	h_exp(char *input, uint16_t *i, t_t_list *t_list, t_sh *shell)
{
	char	*status;

	(*i)++;
	if (input[*i] == '?')
	{
		status = ft_itoa(shell->exit_status);
		add_token(t_list, create_token(status, TOKEN_EXPAND));
		free(status);
		(*i)++;
	}
	else if (input[*i] == '{')
		handle_brace_expand(input, i, t_list);
	else
		h_alnum_ex(input, i, t_list, shell);
}

char	*parse_env_var(char *input, uint16_t *i, t_sh *shell)
{
	char	var_name[256];
	char	*env_value;
	size_t	var_len;

	var_len = 0;
	while (input[*i] && ft_isalnum(input[*i]) && var_len < sizeof(var_name) - 1)
	{
		var_name[var_len] = input[*i];
		var_len++;
		(*i)++;
	}
	var_name[var_len] = '\0';
	env_value = get_env_value(shell, var_name);
	if (env_value)
		return (env_value);
	else
		return ("");
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils5.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fflamion <fflamion@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/03 16:40:08 by fflamion          #+#    #+#             */
/*   Updated: 2024/11/12 15:20:03 by fflamion         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minishell.h"

bool	check_path(char *path, char *command)
{
	char	*full_path;
	int		exists;

	full_path = ft_strjoin(path, "/");
	if (!full_path)
		return (false);
	full_path = ft_strjoin_free(full_path, command);
	if (!full_path)
		return (false);
	exists = (access(full_path, X_OK) == 0);
	free(full_path);
	return (exists);
}

bool	command_exists(char *command, t_sh *shell)
{
	char	*path;
	char	**paths;
	int		i;
	bool	found;

	path = get_env_value(shell, "PATH");
	if (!path)
		return (false);
	paths = ft_split(path, ':');
	if (!paths)
		return (false);
	i = 0;
	found = false;
	while (paths[i] && !found)
	{
		found = check_path(paths[i], command);
		i++;
	}
	ft_free_split(paths);
	return (found);
}

void	h_par(char c, uint16_t *i, t_t_list *t_list)
{
	if (c == '(')
		add_token(t_list, create_token("(", TOKEN_LPAREN));
	else if (c == ')')
		add_token(t_list, create_token(")", TOKEN_RPAREN));
	(*i)++;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils6.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fflamion <fflamion@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/10 13:33:17 by fflamion          #+#    #+#             */
/*   Updated: 2024/11/12 01:20:07 by fflamion         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minishell.h"

typedef struct s_process_data
{
	char		*input;
	t_t_list	*t_list;
	t_sh		*shell;
}				t_process_data;

void	handle_exit_status(uint16_t *i, char *buffer, size_t *j,
		t_sh *shell)
{
	char	*env_value;
	char	*tmp;

	(*i) += 2;
	env_value = ft_itoa(shell->exit_status);
	if (!env_value)
		return ;
	tmp = env_value;
	while (*env_value && *j < 255)
		buffer[(*j)++] = *env_value++;
	free(tmp);
}

void	handle_env_var(uint16_t *i, char *buffer, size_t *j,
		t_process_data *data)
{
	char	*env_value;

	(*i)++;
	env_value = parse_env_var(data->input, i, data->shell);
	if (!env_value)
		return ;
	while (env_value && *env_value && *j < 255)
		buffer[(*j)++] = *env_value++;
}

void	process_double_quotes(uint16_t *i, char *buffer, size_t *j,
		t_process_data *data)
{
	while (data->input[*i] && data->input[*i] != '\"')
	{
		if (data->input[*i] == '$' && data->input[*i + 1] == '?')
			handle_exit_status(i, buffer, j, data->shell);
		else if (data->input[*i] == '$')
			handle_env_var(i, buffer, j, data);
		else if (*j < 255)
			buffer[(*j)++] = data->input[(*i)++];
	}
}

void	h_d_q(char *input, uint16_t *i, t_t_list *t_list, t_sh *shell)
{
	char			buffer[256];
	size_t			j;
	t_process_data	data;

	j = 0;
	data.input = input;
	data.t_list = t_list;
	data.shell = shell;
	(*i)++;
	process_double_quotes(i, buffer, &j, &data);
	buffer[j] = '\0';
	add_token(t_list, create_token(buffer, TOKEN_STRING));
	if (input[*i] == '\"')
		(*i)++;
	else
		ft_putstr_fd("Error: Missing closing double quote\n", 2);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils2.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fflamion <fflamion@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/12 15:19:19 by fflamion          #+#    #+#             */
/*   Updated: 2024/11/12 19:30:57 by fflamion         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minishell.h"

int	is_first_token(t_t_list *t_list)
{
	return (!t_list->first || (t_list->last && (t_list->last->type == TOKEN_PIPE
				|| t_list->last->type == TOKEN_AND
				|| t_list->last->type == TOKEN_OR
				|| t_list->last->type == TOKEN_LPAREN)));
}

void	h_cmd_arg(char *input, uint16_t *i, t_t_list *t_list, t_sh *shell)
{
	char	buffer[256];
	int		j;

	j = 0;
	while (input[*i] && !ft_isspace(input[*i]) && input[*i] != '|'
		&& input[*i] != '>' && input[*i] != '<' && j < (int) sizeof(buffer) - 1
		&& input[*i] != '(' && input[*i] != ')')
	{
		buffer[j++] = input[(*i)++];
	}
	buffer[j] = '\0';
	if (is_first_token(t_list))
	{
		if (command_exists(buffer, shell))
			add_token(t_list, create_token(buffer, TOKEN_COMMAND));
		else
			add_token(t_list, create_token(buffer, TOKEN_ARGUMENT));
	}
	else
		add_token(t_list, create_token(buffer, TOKEN_ARGUMENT));
}

void	handle_and(uint16_t *i, t_t_list *t_list)
{
	add_token(t_list, create_token("&&", TOKEN_AND));
	(*i) += 2;
}

void	handle_wildcards(uint16_t *i, t_t_list *t_list)
{
	add_token(t_list, create_token("*", TOKEN_WILDCARDS));
	(*i)++;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parser.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fflamion <fflamion@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/29 14:48:46 by fflamion          #+#    #+#             */
/*   Updated: 2024/11/12 15:21:12 by fflamion         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minishell.h"

int	verif_redir_in_out_set(t_token *redir_in_token)
{
	t_token_type	n_type;
	int				check_mask;

	if (!redir_in_token->next)
	{
		printf("minishell: syntax error near unexpected token `newline'\n");
		return (1);
	}
	n_type = redir_in_token->next->type;
	check_mask = TOKEN_STRING | TOKEN_COMMAND | TOKEN_EXPAND | TOKEN_ARGUMENT;
	if (!(n_type & check_mask))
	{
		if (redir_in_token->next)
			printf("minishell: syntax error near unexpected token `%s'\n",
				redir_in_token->next->value);
		else
			printf("minishell: syntax error near unexpected token `newline'\n");
		return (1);
	}
	return (0);
}

int	verif_operand_set(t_token *operand_token)
{
	t_token_type	p_type;
	int				check_mask;

	if (!operand_token->index || !operand_token->next)
	{
		printf("minishell: syntax error near unexpected token `%s'\n",
			operand_token->value);
		return (1);
	}
	p_type = operand_token->prev->type;
	check_mask = (TOKEN_ARGUMENT | TOKEN_STRING
			| TOKEN_WILDCARDS | TOKEN_EXPAND
			| TOKEN_COMMAND | TOKEN_RPAREN);
	if (!(p_type & check_mask))
	{
		printf("minishell: syntax error near unexpected token `%s'\n",
			operand_token->value);
		return (1);
	}
	return (0);
}

int	check_parentheses_balance(t_t_list *token_list)
{
	t_token	*current_token;
	int		balance;

	current_token = token_list->first;
	balance = 0;
	while (current_token)
	{
		if (current_token->type == TOKEN_LPAREN)
			balance++;
		else if (current_token->type == TOKEN_RPAREN)
			balance--;
		if (balance < 0)
		{
			printf("minishell: syntax error near unexpected token `%s'\n",
				current_token->value);
			return (1);
		}
		current_token = current_token->next;
	}
	if (balance != 0)
	{
		printf("minishell: syntax error: unmatched parentheses\n");
		return (1);
	}
	return (0);
}

int	check_token_type(t_token *token)
{
	int	status;

	status = 0;
	if (token->type == TOKEN_PIPE)
		status = verif_pipe(token);
	else if (token->type & (TOKEN_REDIRECTION_IN
			| TOKEN_HEREDOC | TOKEN_REDIRECTION_OUT
			| TOKEN_APPEND))
		status = verif_redir_in_out_set(token);
	else if (token->type & (TOKEN_AND | TOKEN_OR))
		status = verif_operand_set(token);
	else if (token->type == TOKEN_RPAREN)
		status = verif_rparen(token);
	return (status);
}

int	parser(t_t_list *token_list)
{
	t_token	*token_cursor;
	int		status;

	if (!token_list->size)
		return (1);
	token_cursor = token_list->first;
	status = 0;
	if (check_parentheses_balance(token_list))
		return (1);
	while (token_cursor)
	{
		status = check_token_type(token_cursor);
		if (status)
			return (status);
		token_cursor = token_cursor->next;
	}
	return (0);
}
// int	parser(t_t_list *token_list)
// {
// 	t_token	*token_cursor;
// 	int		status;

// 	if (!token_list->size)
// 		return (1);
// 	token_cursor = token_list->first;
// 	status = 0;
// 	if (check_parentheses_balance(token_list))
// 		return (1);
// 	while (token_cursor)
// 	{
// 		if (token_cursor->type == TOKEN_PIPE)
// 			status = verif_pipe(token_cursor);
// 		else if (token_cursor->type & (TOKEN_REDIRECTION_IN
		// | TOKEN_HEREDOC | TOKEN_REDIRECTION_OUT | TOKEN_APPEND))
// 			status = verif_redir_in_out_set(token_cursor);
// 		else if (token_cursor->type & (TOKEN_AND | TOKEN_OR))
// 			status = verif_operand_set(token_cursor);
// 		else if (token_cursor->type == TOKEN_RPAREN)
// 			status = verif_rparen(token_cursor);
// 		else if (token_cursor->type == TOKEN_INCONNU)
// 			status = verif_unknown(token_cursor);
// 		if (status)
// 			return (status);
// 		token_cursor = token_cursor->next;
// 	}
// 	return (0);
// }

// int	verif_unknown(t_token *unknown_token)
// {
// 	// printf("minishell: syntax error near unexpected token : `%s'\n",
// 	// 	unknown_token->value);
// 	return (1);
// }
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parser_utils.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fflamion <fflamion@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/03 16:46:24 by fflamion          #+#    #+#             */
/*   Updated: 2024/11/11 03:58:13 by fflamion         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minishell.h"

int	verif_pipe(t_token *pipe_token)
{
	t_token_type	p_type;
	int				check_mask;

	if (!pipe_token->index || !pipe_token->next)
	{
		printf("minishell: syntax error near unexpected token `|'\n");
		return (1);
	}
	p_type = pipe_token->prev->type;
	check_mask = (TOKEN_COMMAND
			| TOKEN_VARIABLE | TOKEN_STRING
			| TOKEN_ARGUMENT | TOKEN_EXPAND | TOKEN_RPAREN);
	if (!(p_type & check_mask))
	{
		printf("minishell: syntax error near unexpected token `|'\n");
		return (1);
	}
	return (0);
}

int	verif_rparen(t_token *par_token)
{
	if (par_token->prev->type == TOKEN_LPAREN)
	{
		printf("minishell: syntax error near unexpected token : `)'\n");
		return (1);
	}
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   signal.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fflamion <fflamion@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/30 09:34:38 by fflamion          #+#    #+#             */
/*   Updated: 2024/11/12 15:20:03 by fflamion         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minishell.h"

void	handle_sigint(int sig)
{
	if (sig == SIGINT)
	{
		write(1, "\n", 1);
		rl_on_new_line();
		rl_replace_line("", 0);
		rl_redisplay();
	}
}

void	setup_signals(void)
{
	struct sigaction	sa;

	sa.sa_handler = &handle_sigint;
	sigemptyset(&sa.sa_mask);
	sa.sa_flags = SA_RESTART;
	sigaction(SIGINT, &sa, NULL);
	sa.sa_handler = SIG_IGN;
	sigaction(SIGQUIT, &sa, NULL);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   export_utils2.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fflamion <fflamion@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/11 06:44:30 by fflamion          #+#    #+#             */
/*   Updated: 2024/11/12 15:20:03 by fflamion         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minishell.h"

static void	sort_env_copy(t_var *env_copy, size_t env_size)
{
	int		has_swapped;
	size_t	i;

	has_swapped = 1;
	while (has_swapped)
	{
		has_swapped = 0;
		i = 0;
		while (i < env_size - 1)
		{
			if (ft_strcmp(env_copy[i].title, env_copy[i + 1].title) > 0)
			{
				swap_values(&env_copy[i], &env_copy[i + 1]);
				has_swapped = 1;
			}
			i++;
		}
	}
}

static void	print_env_vars(t_var *env_copy, size_t env_size)
{
	size_t	i;

	i = 0;
	while (i < env_size)
	{
		printf("export %s=\"%s\"\n", env_copy[i].title, env_copy[i].value);
		i++;
	}
}

static void	free_env_copy(t_var *env_copy, size_t env_size)
{
	size_t	i;

	i = 0;
	while (i < env_size)
	{
		free(env_copy[i].title);
		free(env_copy[i].value);
		i++;
	}
	free(env_copy);
}

void	print_sorted_env(t_sh *shell)
{
	t_var	*env_copy;
	size_t	env_size;

	env_size = shell->env_size - 1;
	env_copy = copy_env(shell);
	if (!env_copy)
		return ;
	sort_env_copy(env_copy, env_size);
	print_env_vars(env_copy, env_size);
	free_env_copy(env_copy, env_size);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   pwd.c                                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fflamion <fflamion@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/06 15:20:10 by fflamion          #+#    #+#             */
/*   Updated: 2024/11/12 15:21:00 by fflamion         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minishell.h"

int	ft_pwd(void)
{
	char	pwd[PATH_MAX];

	if (!getcwd(pwd, PATH_MAX))
		return (ft_putstr_fd("minishell: pwd: error getting current directory\n",
				2), 1);
	ft_putstr_fd(pwd, STDOUT_FILENO);
	ft_putstr_fd("\n", STDOUT_FILENO);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   export.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fflamion <fflamion@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/04 15:07:26 by fflamion          #+#    #+#             */
/*   Updated: 2024/11/12 15:21:00 by fflamion         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minishell.h"
#include "../../include/shell.h"

static int	verify_arg(char *arg)
{
	size_t	i;

	if (!ft_isalpha(arg[0]))
	{
		printf("minishell: export: %s not a valid identifier\n", arg);
		return (1);
	}
	i = 1;
	while (arg[i] && arg[i] != '=')
	{
		if (!ft_isalnum(arg[i]))
		{
			printf("minishell: export: %s not a valid identifier\n", arg);
			return (1);
		}
		i++;
	}
	if (!ft_strchr(arg, '='))
		return (1);
	return (0);
}

void	mod_var(t_sh *shell, char *var_title, char *var_value)
{
	t_var	*existing_value;

	existing_value = var_exists(shell, var_title);
	free(existing_value->value);
	existing_value->value = ft_strdup(var_value);
}

void	add_var(t_sh *shell, char *var_title, char *var_value)
{
	t_var	*new_env;
	size_t	i;

	i = 0;
	new_env = malloc(sizeof(t_var) * (shell->env_size + 1));
	if (!new_env)
		return ;
	while (i < shell->env_size - 1)
	{
		new_env[i].title = ft_strdup(shell->env[i].title);
		new_env[i].value = ft_strdup(shell->env[i].value);
		free(shell->env[i].title);
		free(shell->env[i].value);
		i++;
	}
	new_env[i].title = ft_strdup(var_title);
	new_env[i].value = ft_strdup(var_value);
	new_env[i + 1].title = NULL;
	new_env[i + 1].value = NULL;
	shell->env_size++;
	free(shell->env);
	shell->env = new_env;
}

int	process_export_arg(char *arg, t_sh *shell)
{
	char	**split_str;

	if (verify_arg(arg))
		return (1);
	split_str = ft_split(arg, '=');
	if (!split_str[1])
	{
		ft_free_split(split_str);
		return (0);
	}
	if (var_exists(shell, split_str[0]))
		mod_var(shell, split_str[0], split_str[1]);
	else
		add_var(shell, split_str[0], split_str[1]);
	ft_free_split(split_str);
	return (0);
}

int	ft_export(char **args, t_sh *shell)
{
	int		status;
	size_t	i;

	status = 0;
	i = 1;
	if (!args[i])
	{
		print_sorted_env(shell);
		return (0);
	}
	while (args[i])
	{
		status = process_export_arg(args[i], shell);
		if (status)
			return (status);
		i++;
	}
	i = -1;
	while (shell->envp[++i])
		free(shell->envp[i]);
	free(shell->envp);
	shell->envp = ret_env_array(shell);
	return (status);
}

// int	ft_export(char **args, t_sh *shell)
// {
// 	char	**split_str;
// 	int		status;
// 	size_t	i;

// 	split_str = NULL;
// 	status = 0;
// 	i = 1;
// 	if (!args[i])
// 		print_sorted_env(shell);
// 	while (args[i])
// 	{
// 		if (verify_arg(args[i]))
// 			return (1);
// 		split_str = ft_split(args[i], '=');
// 		if (!split_str[1])
// 		{
// 			ft_free_split(split_str);
// 			status = 0;
// 			break ;
// 		}
// 		if (var_exists(shell, split_str[0]))
// 		{
// 			mod_var(shell, split_str[0], split_str[1]);
// 		}
// 		else
// 			add_var(shell, split_str[0], split_str[1]);
// 		i++;
// 		free_split(split_str);
// 	}
// 	return (status);
// }
// void	print_sorted_env(t_sh *shell)
// {
// 	t_var	*env_copy;
// 	int		has_swapped;
// 	size_t	i;

// 	has_swapped = 1;
// 	i = 0;
// 	size_t env_size = shell->env_size - 1; // Adjusted for zero-based index
// 	env_copy = copy_env(shell);
// 	if (!env_copy)
// 		return ;
// 	while (has_swapped)
// 	{
// 		has_swapped = 0;
// 		while (i < env_size - 1)
// 		{
// 			if (ft_strcmp(env_copy[i].title, env_copy[i + 1].title) > 0)
// 			{
// 				swap_values(&env_copy[i], &env_copy[i + 1]);
// 				has_swapped = 1;
// 			}
// 			i++;
// 		}
// 		i = 0;
// 	}
// 	while (i < env_size)
// 	{
// 		printf("export %s=\"%s\"\n", env_copy[i].title, env_copy[i].value);
// 		i++;
// 	}
// 	i = 0;
// 	while (i < env_size)
// 	{
// 		free(env_copy[i].title);
// 		free(env_copy[i].value);
// 		i++;
// 	}
// 	free(env_copy);
// }
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   export_utils1.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fflamion <fflamion@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/05 13:43:12 by fflamion          #+#    #+#             */
/*   Updated: 2024/11/12 15:21:00 by fflamion         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minishell.h"
#include "../../include/shell.h"

void	swap_values(t_var *a, t_var *b)
{
	t_var	tmp;

	tmp.title = a->title;
	tmp.value = a->value;
	a->title = b->title;
	a->value = b->value;
	b->title = tmp.title;
	b->value = tmp.value;
}

t_var	*copy_env(t_sh *shell)
{
	t_var	*env_copy;
	size_t	i;
	size_t	env_size;

	i = 0;
	env_size = shell->env_size - 1;
	env_copy = malloc(sizeof(t_var) * (env_size + 1));
	if (!env_copy)
		return (NULL);
	while (i < env_size)
	{
		env_copy[i].title = ft_strdup(shell->env[i].title);
		if (!env_copy[i].title)
			break ;
		env_copy[i].value = ft_strdup(shell->env[i].value);
		if (!env_copy[i].value)
		{
			free(env_copy[i].title);
			break ;
		}
		i++;
	}
	env_copy[i].title = NULL;
	env_copy[i].value = NULL;
	return (env_copy);
}

t_var	*var_exists(t_sh *shell, char *var_to_check)
{
	size_t	i;

	i = 0;
	while (i < shell->env_size - 1)
	{
		if (ft_strcmp(shell->env[i].title, var_to_check) == 0)
			return (&shell->env[i]);
		i++;
	}
	return (NULL);
}
// size_t env_size = shell->env_size - 1;  Adjusted for zero-based index
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   echo.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fflamion <fflamion@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/24 14:14:04 by fflamion          #+#    #+#             */
/*   Updated: 2024/11/12 15:21:00 by fflamion         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minishell.h"

static int	check_n_flag(char **args, int *i)
{
	char	*str;
	int		n_flag;

	n_flag = 0;
	while (args[*i] && !ft_strncmp(args[*i], "-n", 2))
	{
		str = args[*i] + 1;
		while (*str == 'n')
			str++;
		if (*str == '\0')
			n_flag = 1;
		else
			break ;
		(*i)++;
	}
	return (n_flag);
}

int	ft_echo(char **args)
{
	int	i;
	int	n_flag;

	i = 1;
	if (!args[i])
		return (ft_putchar_fd('\n', STDOUT_FILENO), 0);
	n_flag = check_n_flag(args, &i);
	while (args[i])
	{
		ft_putstr_fd(args[i], STDOUT_FILENO);
		if (args[i + 1])
			ft_putchar_fd(' ', STDOUT_FILENO);
		i++;
	}
	if (!n_flag)
		ft_putchar_fd('\n', STDOUT_FILENO);
	return (0);
}
// int	ft_echo(char **args)
// {
// 	int		i;
// 	int		n_flag;
// 	char	*str;

// 	n_flag = 0;
// 	i = 1;
// 	while (args[i] && !ft_strncmp(args[i], "-n", 2))
// 	{
// 		str = args[i] + 1;
// 		while (*str == 'n')
// 			str++;
// 		if (*str == '\0')
// 			n_flag = 1;
// 		else
// 			break ;
// 		i++;
// 	}
// 	while (args[i])
// 	{
// 		write(1, args[i], ft_strlen(args[i]) + 1);
// 		if (args[i + 1])
// 			write(1, (const void *)' ', 2);
// 		i++;
// 	}
// 	if (!n_flag)
// 		write(1, (const void *)'\n', 2);
// 	return (0);
// }

// int	is_n_option(const char *str)
// {
// 	int	i;

// 	i = 2;
// 	if (str[0] != '-' || str[1] != 'n')
// 		return (0);
// 	while (str[i] == 'n')
// 		i++;
// 	return (str[i] == '\0');
// }

// char	**check_option(char **args, int *n_flag)
// {
// 	*n_flag = 0;
// 	while (*args && is_n_option(*args))
// 	{
// 		*n_flag = 1;
// 		args++;
// 	}
// 	return (args);
// }

// int	ft_echo(char **args)
// {
// 	int		n_flag;
// 	size_t	total_len;
// 	size_t	pos;
// 	size_t	len;
// 	char	**start;
// 	char	*buffer;
// 	char	**tmp;

// 	total_len = 0;
// 	pos = 0;
// 	if (!args || !*args)
// 		return (write(1, "\n", 1) != 1);
// 	args++;
// 	start = check_option(args, &n_flag);
// 	tmp = start;
// 	while (*tmp)
// 	{
// 		total_len += ft_strlen(*tmp);
// 		tmp++;
// 	}
// 	if (!n_flag)
// 		total_len++;
// 	buffer = malloc(total_len + 1);
// 	if (!buffer)
// 		return (1);
// 	while (*start)
// 	{
// 		len = ft_strlen(*start);
// 		ft_memcpy(buffer + pos, *start, len);
// 		pos += len;
// 		start++;
// 	}
// 	if (!n_flag)
// 		buffer[pos++] = '\n';
// 	buffer[pos] = '\0';
// 	write(1, buffer, pos);
// 	free(buffer);
// 	return (0);
// }
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   env.c                                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fflamion <fflamion@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/06 15:24:40 by fflamion          #+#    #+#             */
/*   Updated: 2024/11/12 15:21:00 by fflamion         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minishell.h"

int	ft_env(t_sh *shell)
{
	size_t	i;

	i = 0;
	while (i < shell->env_size - 1)
	{
		if (shell->env[i].title && shell->env[i].value)
		{
			ft_putstr_fd(shell->env[i].title, STDOUT_FILENO);
			ft_putstr_fd("=", STDOUT_FILENO);
			ft_putstr_fd(shell->env[i].value, STDOUT_FILENO);
			ft_putstr_fd("\n", STDOUT_FILENO);
		}
		i++;
	}
	return (0);
}
// -1 pour viter l'entre NULL finale/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   cd.c                                               :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fflamion <fflamion@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/24 14:29:27 by fflamion          #+#    #+#             */
/*   Updated: 2024/11/12 15:21:00 by fflamion         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minishell.h"

int	handle_cd_error(char *old_pwd, char *path)
{
	free(old_pwd);
	ft_putstr_fd("minishell: cd: ", 2);
	ft_putstr_fd(path, 2);
	ft_putstr_fd(": No such file or directory\n", 2);
	return (1);
}

char	*get_cd_path(char **args, t_sh *shell)
{
	char	*path;

	if (!args[1])
	{
		path = get_env_value(shell, "HOME");
		if (!path)
			return (ft_putstr_fd("minishell: cd: HOME not set\n", 2), NULL);
	}
	else
		path = args[1];
	return (path);
}

int	ft_cd(char **args, t_sh *shell)
{
	char	*path;
	char	*old_pwd;
	char	current_pwd[PATH_MAX];

	path = get_cd_path(args, shell);
	if (!path)
		return (1);
	old_pwd = getcwd(NULL, 0);
	if (!old_pwd)
		return (ft_putstr_fd("minishell: cd: error getting current directory\n",
				2), 1);
	if (chdir(path) == -1)
		return (handle_cd_error(old_pwd, path));
	if (!getcwd(current_pwd, PATH_MAX))
	{
		free(old_pwd);
		return (ft_putstr_fd("minishell: cd: error getting new directory\n", 2),
			1);
	}
	free(old_pwd);
	return (0);
}

// int	ft_cd(char **args, t_sh *shell)
// {
// 	char	*path;
// 	char	*old_pwd;
// 	char	current_pwd[PATH_MAX];

// 	if (!args[1])
// 	{
// 		path = get_env_value("HOME", shell->envp);
// 		if (!path)
// 			return (ft_putstr_fd("minishell: cd: HOME not set\n", 2), 1);
// 	}
// 	else
// 		path = args[1];
// 	old_pwd = getcwd(NULL, 0);
// 	if (!old_pwd)
// 		return (ft_putstr_fd("minishell: cd: error getting current directory\n",
// 				2), 1);
// 	if (chdir(path) == -1)
// 	{
// 		free(old_pwd);
// 		return (ft_putstr_fd("minishell: cd: ", 2), ft_putstr_fd(path, 2),
// 			ft_putstr_fd(": No such file or directory\n", 2), 1);
// 	}
// 	if (!getcwd(current_pwd, PATH_MAX))
// 	{
// 		free(old_pwd);
// 		return (ft_putstr_fd("minishell: cd: error getting new directory\n", 2),
// 			1);
// 	}
// 	free(old_pwd);
// 	return (0);
// }
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   unset.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fflamion <fflamion@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/05 13:11:54 by fflamion          #+#    #+#             */
/*   Updated: 2024/11/12 15:21:00 by fflamion         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minishell.h"
#include "../../include/shell.h"

int	verify_arg(char *arg)
{
	if (!ft_isalpha(*arg))
		return (1);
	while (*arg)
	{
		if (!ft_isalnum(*arg))
			return (1);
		arg++;
	}
	return (0);
}

void	remove_var(t_sh *shell, char *var_title)
{
	t_var	*new_env;
	size_t	i;
	size_t	y;

	new_env = NULL;
	i = 0;
	y = 0;
	new_env = malloc(sizeof(t_var) * shell->env_size);
	if (!new_env)
		return ;
	while (i < shell->env_size - 1)
	{
		if (ft_strcmp(shell->env[i].title, var_title))
		{
			new_env[y].title = ft_strdup(shell->env[i].title);
			new_env[y].value = ft_strdup(shell->env[i].value);
			y++;
		}
		free(shell->env[i].title);
		free(shell->env[i].value);
		i++;
	}
	shell->env_size--;
	free(shell->env);
	shell->env = new_env;
}

int	ft_unset(char **args, t_sh *shell)
{
	size_t	i;

	i = 1;
	while (args[i])
	{
		if (verify_arg(args[i]))
		{
			printf("minishell: unset: `%s' not a valid identifier\n", args[i]);
			return (1);
		}
		if (!var_exists(shell, args[i]))
		{
			i++;
			continue ;
		}
		remove_var(shell, args[i]);
		i++;
	}
	return (0);
}
// if (!var_exists(shell, args[i])) //if variable does not exist, 
// avoid useless copy
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   exit.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fflamion <fflamion@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/06 15:26:42 by nghaddar          #+#    #+#             */
/*   Updated: 2024/11/12 19:58:52 by fflamion         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minishell.h"

void	free_candies(t_sh *shell, t_ast_node *node)
{
	if (shell)
		free_shell(shell);
	if (node)
		free_ast(node);
}

int	ft_exit(char **args, t_sh *shell, t_ast_node *node)
{
	long long	exit_code;
	char		*endptr;

	printf("exit\n");
	if (!args[1])
	{
		free_candies(shell, node);
		exit(0);
	}
	exit_code = strtoll(args[1], &endptr, 10);
	if (*endptr != '\0' || args[1][0] == '\0')
	{
		ft_putstr_fd("minishell: exit: ", 2);
		ft_putstr_fd(args[1], 2);
		ft_putstr_fd(": numeric argument required\n", 2);
		free_candies(shell, node);
		exit(2);
	}
	if (args[2])
	{
		ft_putstr_fd("minishell: exit: too many arguments\n", 2);
		return (1);
	}
	free_candies(shell, node);
	exit((unsigned char)exit_code);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   exec_cmd.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fflamion <fflamion@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/11 02:32:08 by fflamion          #+#    #+#             */
/*   Updated: 2024/11/12 19:15:11 by fflamion         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minishell.h"

int						is_builtin(char *cmd);

char	**cp_argv(t_ast_node *node)
{
	int		i;
	char	**argv;
	int		j;

	i = 0;
	while (node->argv[i])
		i++;
	argv = malloc(sizeof(char *) * (i + 1));
	if (!argv)
		return (NULL);
	j = 0;
	while (j <= i)
	{
		if (node->argv[j])
			argv[j] = ft_strdup(node->argv[j]);
		else
			argv[j] = NULL;
		j++;
	}
	return (argv);
}

int	execute_builtin(t_ast_node *node, t_sh *shell)
{
	char	*cmd;

	cmd = node->argv[0];
	if (!ft_strcmp(cmd, "echo"))
		return (ft_echo(node->argv));
	if (!ft_strcmp(cmd, "cd"))
		return (ft_cd(node->argv, shell));
	if (!ft_strcmp(cmd, "pwd"))
		return (ft_pwd());
	if (!ft_strcmp(cmd, "export"))
		return (ft_export(node->argv, shell));
	if (!ft_strcmp(cmd, "unset"))
		return (ft_unset(node->argv, shell));
	if (!ft_strcmp(cmd, "env"))
		return (ft_env(shell));
	if (!ft_strcmp(cmd, "exit"))
		return (ft_exit(node->argv, shell, node));
	return (1);
}

int	execute_builtin_command(t_ast_node *node, t_sh *shell)
{
	int	original_stdin;
	int	original_stdout;
	int	status;

	original_stdin = dup(STDIN_FILENO);
	original_stdout = dup(STDOUT_FILENO);
	handle_redirections(node);
	status = execute_builtin(node, shell);
	dup2(original_stdin, STDIN_FILENO);
	dup2(original_stdout, STDOUT_FILENO);
	close(original_stdin);
	close(original_stdout);
	shell->exit_status = status;
	return (status);
}

typedef struct s_exec_data
{
	struct sigaction	orig_int;
	struct sigaction	orig_quit;
	pid_t				pid;
	int					status;
}						t_exec_data;

int	handle_external_command(t_ast_node *node, t_sh *shell)
{
	t_exec_data	data;

	save_og_s(&data.orig_int, &data.orig_quit);
	data.pid = create_child_process(node, shell);
	if (data.pid < 0)
	{
		perror("minishell");
		return (-1);
	}
	if (data.pid > 0)
		return (w_c(data.pid, shell, &data.orig_int, &data.orig_quit));
	return (0);
}

int	execute_command_node(t_ast_node *node, t_sh *shell)
{
	if (is_builtin(node->argv[0]))
		return (execute_builtin_command(node, shell));
	return (handle_external_command(node, shell));
}

// int	execute_command_node(t_ast_node *node, t_sh *shell)
// {
// 	int					original_stdin;
// 	int					original_stdout;
// 	int					status;
// 	pid_t				pid;
// 	struct sigaction	orig_int;
// 	struct sigaction	orig_quit;

// 	if (is_builtin(node->argv[0]))
// 		return (execute_builtin_command(node, shell));
// 	else
// 	{
// 		save_og_s(&orig_int, &orig_quit);
// 		pid = create_child_process(node, shell);
// 		if (pid < 0)
// 		{
// 			perror("minishell");
// 			return (-1);
// 		}
// 		if (pid > 0)
// 			return (w_c(pid, shell, &orig_int, &orig_quit));
// 		return (0);
// 	}
// }
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   exec_pipe.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fflamion <fflamion@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/11 02:29:37 by fflamion          #+#    #+#             */
/*   Updated: 2024/11/12 03:41:52 by fflamion         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minishell.h"

int	setup_pipe(int pipefd[2])
{
	if (pipe(pipefd) == -1)
	{
		perror("minishell");
		return (-1);
	}
	return (0);
}

void	execute_left_child(t_ast_node *node, t_sh *shell, int pipefd[2])
{
	pid_t	pid_left;

	pid_left = fork();
	if (pid_left == 0)
	{
		dup2(pipefd[1], STDOUT_FILENO);
		close(pipefd[0]);
		close(pipefd[1]);
		execute_ast(node->left, shell);
		free_ast(node);
		free_shell(shell);
		exit(shell->exit_status);
	}
}

void	execute_right_child(t_ast_node *node, t_sh *shell, int pipefd[2])
{
	pid_t	pid_right;

	pid_right = fork();
	if (pid_right == 0)
	{
		dup2(pipefd[0], STDIN_FILENO);
		close(pipefd[0]);
		close(pipefd[1]);
		execute_ast(node->right, shell);
		free_ast(node);
		free_shell(shell);
		exit(shell->exit_status);
	}
}

int	execute_pipe_node(t_ast_node *node, t_sh *shell)
{
	int	pipefd[2];
	int	status;

	if (setup_pipe(pipefd) == -1)
		return (-1);
	execute_left_child(node, shell, pipefd);
	execute_right_child(node, shell, pipefd);
	close(pipefd[0]);
	close(pipefd[1]);
	waitpid(-1, &status, 0);
	waitpid(-1, &status, 0);
	update_exit_status(shell, status);
	return (shell->exit_status);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   executor.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fflamion <fflamion@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/01 18:12:34 by fflamion          #+#    #+#             */
/*   Updated: 2024/11/11 02:35:00 by fflamion         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minishell.h"

int	execute_ast(t_ast_node *node, t_sh *shell)
{
	if (!node)
		return (0);
	if (node->type == AST_COMMAND)
		return (execute_command_node(node, shell));
	else if (node->type == AST_PIPE)
		return (execute_pipe_node(node, shell));
	else if (node->type == AST_AND)
		return (execute_and_node(node, shell));
	else if (node->type == AST_OR)
		return (execute_or_node(node, shell));
	return (0);
}

int	execute_and_node(t_ast_node *node, t_sh *shell)
{
	int	status;

	status = execute_ast(node->left, shell);
	shell->exit_status = status;
	if (status == 0)
		return (execute_ast(node->right, shell));
	return (status);
}

int	execute_or_node(t_ast_node *node, t_sh *shell)
{
	int	status;

	status = execute_ast(node->left, shell);
	shell->exit_status = status;
	if (status != 0)
		return (execute_ast(node->right, shell));
	return (status);
}
// int	execute_pipe_node(t_ast_node *node, t_sh *shell)
// {
// 	int		pipefd[2];
// 	pid_t	pid_left;
// 	pid_t	pid_right;
// 	int		status;

// 	if (pipe(pipefd) == -1)
// 		return (perror("minishell"), -1);
// 	pid_left = fork();
// 	if (pid_left == 0)
// 	{
// 		dup2(pipefd[1], STDOUT_FILENO);
// 		close(pipefd[0]);
// 		close(pipefd[1]);
// 		execute_ast(node->left, shell);
// 		exit(shell->exit_status);
// 	}
// 	pid_right = fork();
// 	if (pid_right == 0)
// 	{
// 		dup2(pipefd[0], STDIN_FILENO);
// 		close(pipefd[0]);
// 		close(pipefd[1]);
// 		execute_ast(node->right, shell);
// 		exit(shell->exit_status);
// 	}
// 	close(pipefd[0]);
// 	close(pipefd[1]);
// 	waitpid(pid_left, &status, 0);
// 	waitpid(pid_right, &status, 0);
// 	update_exit_status(shell, status);
// 	return (shell->exit_status);
// }/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   executor_utils1.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fflamion <fflamion@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/03 16:53:15 by fflamion          #+#    #+#             */
/*   Updated: 2024/11/10 21:22:04 by fflamion         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minishell.h"

void	handle_redir_in(t_ast_node *node)
{
	int	fd;

	fd = open(node->filename, O_RDONLY);
	if (fd == -1)
	{
		perror("minishell");
		free_ast(node);
		exit(EXIT_FAILURE);
	}
	dup2(fd, STDIN_FILENO);
	close(fd);
}

void	handle_redir_out(t_ast_node *node, int flags)
{
	int	fd;

	fd = open(node->filename, flags, 0644);
	if (fd == -1)
	{
		perror("minishell");
		free_ast(node);
		exit(EXIT_FAILURE);
	}
	dup2(fd, STDOUT_FILENO);
	close(fd);
}

void	handle_redirections(t_ast_node *node)
{
	t_ast_node	*redir;

	redir = node->left;
	while (redir)
	{
		if (redir->type == AST_REDIRECTION_IN)
			handle_redir_in(redir);
		else if (redir->type == AST_REDIRECTION_OUT)
			handle_redir_out(redir, O_WRONLY | O_CREAT | O_TRUNC);
		else if (redir->type == AST_REDIRECTION_APPEND)
			handle_redir_out(redir, O_WRONLY | O_CREAT | O_APPEND);
		else if (redir->type == AST_REDIRECTION_HEREDOC)
			handle_redir_heredoc(redir);
		redir = redir->left;
	}
}
// void	handle_redir_heredoc(t_ast_node *node)
// {
// 	char	*line;
// 	int		fd;
// 	char	*delimiter;

// 	// Crer un fichier temporaire pour le heredoc
// 	fd = open("/tmp/heredoc_tmp", O_CREAT | O_WRONLY | O_TRUNC, 0644);
// 	if (fd == -1)
// 	{
// 		perror("minishell: heredoc");
// 		exit(EXIT_FAILURE);
// 	}
// 	delimiter = node->filename;
// 	while (1)
// 	{
// 		line = readline("> ");
// 		if (!line)
// 			break ;
// 		if (ft_strcmp(line, delimiter) == 0)
// 		{
// 			free(line);
// 			break ;
// 		}
// 		write(fd, line, ft_strlen(line));
// 		write(fd, "\n", 1);
// 		free(line);
// 	}
// 	close(fd);
// 	// Rouvrir le fichier pour la lecture
// 	fd = open("/tmp/heredoc_tmp", O_RDONLY);
// 	if (fd == -1)
// 	{
// 		perror("minishell: heredoc");
// 		exit(EXIT_FAILURE);
// 	}
// 	dup2(fd, STDIN_FILENO);
// 	close(fd);
// 	unlink("/tmp/heredoc_tmp"); // Supprimer le fichier temporaire
// }/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   executor_utils2.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fflamion <fflamion@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/05 08:09:09 by fflamion          #+#    #+#             */
/*   Updated: 2024/11/05 19:17:35 by fflamion         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minishell.h"

void	set_s_h(struct sigaction *sa, int signum, void (*handler)(int))
{
	sa->sa_handler = handler;
	sigemptyset(&sa->sa_mask);
	sa->sa_flags = 0;
	sigaction(signum, sa, NULL);
}

void	save_og_s(struct sigaction *orig_int, struct sigaction *orig_quit)
{
	sigaction(SIGINT, NULL, orig_int);
	sigaction(SIGQUIT, NULL, orig_quit);
}

void	res_sig(struct sigaction *orig_int, struct sigaction *orig_quit)
{
	sigaction(SIGINT, orig_int, NULL);
	sigaction(SIGQUIT, orig_quit, NULL);
}

void	set_signals_for_parent(struct sigaction *sa_ignore)
{
	set_s_h(sa_ignore, SIGINT, SIG_IGN);
	set_s_h(sa_ignore, SIGQUIT, SIG_IGN);
}

void	set_signals_for_child(struct sigaction *sa_default)
{
	set_s_h(sa_default, SIGINT, SIG_DFL);
	set_s_h(sa_default, SIGQUIT, SIG_DFL);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   executor_utils3.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fflamion <fflamion@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/05 08:12:14 by fflamion          #+#    #+#             */
/*   Updated: 2024/11/12 17:12:02 by fflamion         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minishell.h"

int	w_c(pid_t pid, t_sh *shell, struct sigaction *orig_int,
		struct sigaction *orig_quit)
{
	int					status;
	struct sigaction	sa_ignore;

	set_signals_for_parent(&sa_ignore);
	waitpid(pid, &status, 0);
	update_exit_status(shell, status);
	res_sig(orig_int, orig_quit);
	if (WIFSIGNALED(status) && WTERMSIG(status) == SIGINT)
		write(1, "\n", 1);
	return (shell->exit_status);
}

void	handle_exec_error(t_ast_node *node, t_sh *shell)
{
	ft_putstr_fd("minishell: ", 2);
	ft_putstr_fd(node->argv[0], 2);
	free_ast(node);
	free_shell(shell);
	if (errno == ENOENT)
	{
		ft_putstr_fd(": command not found\n", 2);
		exit(127);
	}
	ft_putstr_fd(": ", 2);
	ft_putstr_fd(strerror(errno), 2);
	ft_putstr_fd("\n", 2);
	exit(126);
}

// char	*find_executable_path(char *command, t_sh *shell)
// {
// 	char	*path_env;
// 	char	**paths;
// 	char	*full_path;
// 	int		i;

// 	i = 0;
// 	path_env = get_env_value(shell, "PATH");
// 	paths = ft_split(path_env, ':');
// 	full_path = NULL;
// 	if (!paths)
// 		return (NULL);
// 	while (paths[i] != NULL)
// 	{
// 		full_path = ft_strjoin(paths[i], "/");
// 		full_path = ft_strjoin_free(full_path, command);
// 		if (access(full_path, X_OK) == 0)
// 		{
// 			ft_free_split(paths);
// 			return (full_path);
// 		}
// 		free(full_path);
// 		i++;
// 	}
// 	ft_free_split(paths);
// 	return (NULL);
// }

// char	*find_executable_path(char *command, t_sh *shell)
// {
// 	char	*path_env;
// 	char	**paths;
// 	char	*full_path;
// 	int		i;

// 	// Vrifier si la commande contient un '/'
// 	if (ft_strchr(command, '/'))
// 	{
// 		// Tenter d'accder directement au chemin fourni
// 		if (access(command, X_OK) == 0)
// 			return (ft_strdup(command));
// 		else
// 			return (NULL);
// 	}
// 	// Sinon, rechercher dans les rpertoires du PATH
// 	i = 0;
// 	path_env = get_env_value(shell, "PATH");
// 	if (!path_env)
// 		return (NULL);
// 	paths = ft_split(path_env, ':');
// 	if (!paths)
// 		return (NULL);
// 	while (paths[i] != NULL)
// 	{
// 		full_path = ft_strjoin(paths[i], "/");
// 		if (!full_path)
// 		{
// 			ft_free_split(paths);
// 			return (NULL);
// 		}
// 		full_path = ft_strjoin_free(full_path, command);
// 		if (!full_path)
// 		{
// 			ft_free_split(paths);
// 			return (NULL);
// 		}
// 		if (access(full_path, X_OK) == 0)
// 		{
// 			ft_free_split(paths);
// 			return (full_path);
// 		}
// 		free(full_path);
// 		i++;
// 	}
// 	ft_free_split(paths);
// 	return (NULL);
// }

void	execute_child(t_ast_node *node, struct sigaction *sa_default,
		t_sh *shell)
{
	char	*path;

	set_signals_for_child(sa_default);
	handle_redirections(node);
	path = find_executable_path(node->argv[0], shell);
	if (!path)
	{
		handle_exec_error(node, shell);
		free_shell(shell);
		free_ast(node);
		exit(127);
	}
	if (execve(path, node->argv, shell->envp) == -1)
	{
		free(path);
		handle_exec_error(node, shell);
	}
	free(path);
	free_shell(shell);
	free_ast(node);
	exit(0);
}

pid_t	create_child_process(t_ast_node *node, t_sh *shell)
{
	pid_t				pid;
	struct sigaction	sa_default;

	pid = fork();
	if (pid == 0)
		execute_child(node, &sa_default, shell);
	return (pid);
}

// void	execute_child(t_ast_node *node, struct sigaction *sa_default,
// 		t_sh *shell)
// {
// 	set_signals_for_child(sa_default);
// 	handle_redirections(node);
// 	if (execvp(node->argv[0], node->argv) == -1)
// 		handle_exec_error(node, shell);
// }

// pid_t	create_child_process(t_ast_node *node)
// {
// 	pid_t				pid;
// 	struct sigaction	sa_default;

// 	pid = fork();
// 	if (pid == 0)
// 	{
// 		set_signals_for_child(&sa_default);
// 		handle_redirections(node);
// 		if (execvp(node->argv[0], node->argv) == -1)
// 		{
// 			if (errno == ENOENT)
// 			{
// 				ft_putstr_fd("minishell: ", 2);
// 				ft_putstr_fd(node->argv[0], 2);
// 				ft_putstr_fd(": command not found", 2);
// 				ft_putstr_fd("\n", 2);
// 				exit(127);
// 			}
// 			else
// 			{
// 				ft_putstr_fd("minishell: ", 2);
// 				ft_putstr_fd(node->argv[0], 2);
// 				ft_putstr_fd(": ", 2);
// 				ft_putstr_fd(strerror(errno), 2);
// 				ft_putstr_fd("\n", 2);
// 				exit(126);
// 			}
// 		}
// 	}
// 	return (pid);
// }
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   executor_utils4.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fflamion <fflamion@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/10 14:21:20 by fflamion          #+#    #+#             */
/*   Updated: 2024/11/12 15:16:10 by fflamion         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minishell.h"

static void	write_heredoc_content(int fd, char *delimiter)
{
	char	*line;

	while (1)
	{
		line = readline("> ");
		if (!line)
			break ;
		if (ft_strcmp(line, delimiter) == 0)
		{
			free(line);
			break ;
		}
		write(fd, line, ft_strlen(line));
		write(fd, "\n", 1);
		free(line);
	}
}

void	setup_heredoc_reading(void)
{
	int	fd;

	fd = open("/tmp/heredoc_tmp", O_RDONLY);
	if (fd == -1)
	{
		perror("minishell: heredoc");
		exit(EXIT_FAILURE);
	}
	dup2(fd, STDIN_FILENO);
	close(fd);
	unlink("/tmp/heredoc_tmp");
}

void	handle_redir_heredoc(t_ast_node *node)
{
	int	fd;

	fd = open("/tmp/heredoc_tmp", O_CREAT | O_WRONLY | O_TRUNC, 0644);
	if (fd == -1)
	{
		perror("minishell: heredoc");
		free_ast(node);
		exit(EXIT_FAILURE);
	}
	write_heredoc_content(fd, node->filename);
	close(fd);
	setup_heredoc_reading();
}

int	is_builtin(char *cmd)
{
	return (!ft_strcmp(cmd, "echo") || !ft_strcmp(cmd, "cd") || !ft_strcmp(cmd,
			"pwd") || !ft_strcmp(cmd, "export") || !ft_strcmp(cmd, "unset")
		|| !ft_strcmp(cmd, "env") || !ft_strcmp(cmd, "exit"));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   executor_utils5.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fflamion <fflamion@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/12 17:10:43 by fflamion          #+#    #+#             */
/*   Updated: 2024/11/12 17:23:23 by fflamion         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minishell.h"

char	*check_absolute_or_relative_path(char *command)
{
	if (access(command, X_OK) == 0)
		return (ft_strdup(command));
	else
		return (NULL);
}

char	*build_full_path(char *dir, char *command)
{
	char	*full_path;

	full_path = ft_strjoin(dir, "/");
	if (!full_path)
		return (NULL);
	full_path = ft_strjoin_free(full_path, command);
	if (!full_path)
		return (NULL);
	if (access(full_path, X_OK) == 0)
		return (full_path);
	free(full_path);
	return (NULL);
}

char	*search_in_path(char *command, t_sh *shell)
{
	char	*path_env;
	char	**paths;
	char	*full_path;
	int		i;

	i = 0;
	path_env = get_env_value(shell, "PATH");
	if (!path_env)
		return (NULL);
	paths = ft_split(path_env, ':');
	if (!paths)
		return (NULL);
	while (paths[i])
	{
		full_path = build_full_path(paths[i], command);
		if (full_path)
		{
			ft_free_split(paths);
			return (full_path);
		}
		i++;
	}
	ft_free_split(paths);
	return (NULL);
}

char	*find_executable_path(char *command, t_sh *shell)
{
	char	*path;

	if (ft_strchr(command, '/'))
		path = check_absolute_or_relative_path(command);
	else
		path = search_in_path(command, shell);
	return (path);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   minishell.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fflamion <fflamion@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/12 15:14:57 by fflamion          #+#    #+#             */
/*   Updated: 2024/11/12 19:16:11 by fflamion         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../include/minishell.h"

void	shelllevel(t_sh *shell)
{
	int		shlvl;
	char	*modvalue;
	size_t	i;

	i = -1;
	while (shell->envp[++i])
		free(shell->envp[i]);
	free(shell->envp);
	shlvl = ft_atoi(get_env_value(shell, "SHLVL"));
	modvalue = ft_itoa(++shlvl);
	mod_var(shell, "SHLVL", modvalue);
	shell->envp = ret_env_array(shell);
	free(modvalue);
}

int	process_input(char *input, t_sh *shell)
{
	t_t_list	*t_list;
	t_ast_node	*ast_root;

	t_list = lexer(input, shell);
	if (!t_list)
		return (1);
	if (parser(t_list))
	{
		free_token_list(t_list);
		return (0);
	}
	ast_root = ast_parser(t_list, shell);
	free_token_list(t_list);
	execute_ast(ast_root, shell);
	free_ast(ast_root);
	return (0);
}

void	main_loop(t_sh *shell)
{
	char	*input;

	setup_signals();
	while (1)
	{
		input = readline("minishell> ");
		if (!input)
		{
			free(input);
			free_shell(shell);
			ft_exit((char *[]){"exit", "127", NULL}, NULL, NULL);
			break ;
		}
		if (*input)
		{
			add_history(input);
			if (process_input(input, shell))
			{
				free(input);
				break ;
			}
		}
		free(input);
	}
}

int	main(int argc, char **argv, char **environ)
{
	t_sh	shell;

	if (argc != 1)
	{
		ft_putstr_fd("minishell: ", 2);
		ft_putstr_fd(argv[1], 2);
		ft_putstr_fd(": No such file or directory\n", 2);
		return (127);
	}
	initialize_shell(&shell, environ);
	shelllevel(&shell);
	main_loop(&shell);
	free_shell(&shell);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   signal.h                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fflamion <fflamion@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/30 09:05:55 by fflamion          #+#    #+#             */
/*   Updated: 2024/11/05 18:44:59 by fflamion         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef SIGNAL_H
# define SIGNAL_H

void	setup_signals(void);

#endif/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parser.h                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fflamion <fflamion@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/29 14:43:43 by fflamion          #+#    #+#             */
/*   Updated: 2024/11/12 15:21:00 by fflamion         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef PARSER_H
# define PARSER_H

# include "shell.h"
# include "lexer.h"

int		parser(t_t_list *token_list);

//utils
int		verif_pipe(t_token *pipe_token);
int		verif_rparen(t_token *par_token);

#endif
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   lexer.h                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fflamion <fflamion@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/24 13:09:54 by fflamion          #+#    #+#             */
/*   Updated: 2024/11/12 15:20:03 by fflamion         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef LEXER_H
# define LEXER_H

# include "minishell.h"

typedef enum e_token_type
{
	TOKEN_COMMAND = (1 << 0),
	TOKEN_ARGUMENT = (1 << 1),
	TOKEN_PIPE = (1 << 2),
	TOKEN_REDIRECTION_IN = (1 << 3),
	TOKEN_REDIRECTION_OUT = (1 << 4),
	TOKEN_APPEND = (1 << 5),
	TOKEN_HEREDOC = (1 << 6),
	TOKEN_VARIABLE = (1 << 7),
	TOKEN_STRING = (1 << 8),
	TOKEN_AND = (1 << 9),
	TOKEN_OR = (1 << 10),
	TOKEN_EOF = (1 << 11),
	TOKEN_WILDCARDS = (1 << 12),
	TOKEN_EXPAND = (1 << 13),
	TOKEN_INCONNU = (1 << 14),
	TOKEN_LPAREN = (1 << 15),
	TOKEN_RPAREN = (1 << 16),
}	t_token_type;

typedef struct s_token
{
	t_token_type		type;
	char				*value;
	uint16_t			index;
	struct s_token		*next;
	struct s_token		*prev;
}	t_token;

typedef struct s_token_list
{
	struct s_token	*first;
	struct s_token	*last;
	unsigned int	size;
}	t_t_list;

// T_List & token utils
t_t_list	*init_t_list(void);
void		free_token_list(t_t_list *t_list);
t_token		*create_token(const char *value, t_token_type type);
void		add_token(t_t_list *t_list, t_token *new_token);

t_t_list	*lexer(char *input, t_sh *shell);

// lexer utils1
void		h_pipe(char *input, uint16_t *i, t_t_list *t_list);
void		h_rout(char *input, uint16_t *i, t_t_list *t_list);
void		h_rin(char *input, uint16_t *i, t_t_list *t_list);
void		h_s_q(char *input, uint16_t *i, t_t_list *t_list);
void		h_d_q(char *input, uint16_t *i, t_t_list *t_list, t_sh *shell);

// lexer utils2
void		h_cmd_arg(char *input, uint16_t *i, t_t_list *t_list, t_sh *shell);
void		handle_and(uint16_t *i, t_t_list *t_list);
void		handle_wildcards(uint16_t *i, t_t_list *t_list);

// lexer utils3
void		h_exp(char *input, uint16_t *i, t_t_list *t_list, t_sh *shell);
char		*parse_env_var(char *input, uint16_t *i, t_sh *shell);

// lexer utils4
void		handle_heredoc(t_token *heredoc_token, char *delimiter);
void		handle_inconnu(char *input, uint16_t *i, t_t_list *t_list);
void		handle_builtin_command(char *input, uint16_t *i, t_t_list *t_list);

// lexer utils5
bool		command_exists(char *command, t_sh *shell);
void		h_par(char c, uint16_t *i, t_t_list *t_list);

#endif
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   minishell.h                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fflamion <fflamion@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/23 09:50:53 by fflamion          #+#    #+#             */
/*   Updated: 2024/11/12 15:12:26 by fflamion         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef MINISHELL_H
# define MINISHELL_H

# include <unistd.h>
# include <stdlib.h>
# include <stdio.h>
# include <limits.h>
# include <stdint.h>
# include <sys/wait.h>
# include <sys/types.h>
# include <dirent.h>
# include <stdbool.h>
# include <fcntl.h>
# include <errno.h>
# include <string.h>
# include <signal.h>
# include <readline/readline.h>
# include <readline/history.h>

# include "../libft/includes/libft.h"
# include "shell.h"
# include "funny.h"
# include "lexer.h"
# include "parser.h"
# include "builtins.h"
# include "signal.h"
# include "ast.h"

#endif/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   funny.h                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fflamion <fflamion@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/05 06:32:06 by fflamion          #+#    #+#             */
/*   Updated: 2024/11/12 00:22:04 by fflamion         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef FUNNY_H
# define FUNNY_H

// typedef struct s_colors
// {
// 	const char	*colors[17];
// 	const char	*reset_color;
// 	int			color_count;
// 	int			index;
// }	t_colors;

// void	init_colors(t_colors *color_set);

#endif/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ast.h                                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fflamion <fflamion@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/01 12:36:31 by fflamion          #+#    #+#             */
/*   Updated: 2024/11/12 17:11:53 by fflamion         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef AST_H
# define AST_H

# include "lexer.h"

typedef enum e_ast_node_type
{
	AST_COMMAND,
	AST_PIPE,
	AST_AND,
	AST_OR,
	AST_REDIRECTION_IN,
	AST_REDIRECTION_OUT,
	AST_REDIRECTION_APPEND,
	AST_REDIRECTION_HEREDOC
}						t_ast_node_type;

typedef struct s_ast_node
{
	t_ast_node_type		type;
	char				**argv;
	char				*filename;
	struct s_ast_node	*left;
	struct s_ast_node	*right;
	t_sh				*shell;
}						t_ast_node;

// ast_list
t_ast_node				*create_ast_node(t_ast_node_type type, t_sh *shell);
void					add_argument(t_ast_node *node, char *argument);
void					free_ast(t_ast_node *node);

// parser
t_ast_node				*ast_parser(t_t_list *token_list, t_sh *shell);
t_ast_node				*parse_parentheses(t_token **current_token,
							t_sh *shell);
t_ast_node				*parse_command(t_token **current_token, t_sh *shell);
t_ast_node				*parse_pipeline(t_token **current_token, t_sh *shell);
t_ast_node				*parse_and_or_sequence(t_token **current_token,
							t_sh *shell);

// parse_redir
void					parse_redir(t_token **curr_t, t_ast_node *cmd_node,
							t_sh *sh);
int						is_redirection_token(t_token *token);

// parse_pipeline
t_ast_node				*parse_pipeline(t_token **current_token, t_sh *shell);
t_ast_node				*parse_parentheses(t_token **current_token,
							t_sh *shell);

// execution
int						execute_ast(t_ast_node *node, t_sh *shell);
int						execute_command_node(t_ast_node *node, t_sh *shell);
int						execute_pipe_node(t_ast_node *node, t_sh *shell);
int						execute_and_node(t_ast_node *node, t_sh *shell);
int						execute_or_node(t_ast_node *node, t_sh *shell);

// executor_utils1
void					handle_redir_in(t_ast_node *node);
void					handle_redir_out(t_ast_node *node, int flags);
void					handle_redirections(t_ast_node *node);
void					handle_redir_heredoc(t_ast_node *node);

// executor_utils2
void					set_s_h(struct sigaction *sa, int signum,
							void (*handler)(int));
void					save_og_s(struct sigaction *orig_int,
							struct sigaction *orig_quit);
void					res_sig(struct sigaction *orig_int,
							struct sigaction *orig_quit);
void					set_signals_for_parent(struct sigaction *sa_ignore);
void					set_signals_for_child(struct sigaction *sa_default);

// executor_utils3
int						w_c(pid_t p, t_sh *s, struct sigaction *b,
							struct sigaction *a);
pid_t					create_child_process(t_ast_node *node, t_sh *shell);

// executor_utils5
char					*find_executable_path(char *command, t_sh *shell);
#endif
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   builtins.h                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fflamion <fflamion@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/06 20:04:50 by fflamion          #+#    #+#             */
/*   Updated: 2024/11/12 19:16:27 by fflamion         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef BUILTINS_H
# define BUILTINS_H

# include "ast.h"
# include "shell.h"
# include <limits.h>

// utils
t_var	*copy_env(t_sh *shell);

int		ft_echo(char **args);
int		ft_cd(char **args, t_sh *shell);
int		ft_pwd(void);
int		ft_export(char **args, t_sh *shell);
int		ft_unset(char **args, t_sh *shell);
int		ft_env(t_sh *shell);
int		ft_exit(char **args, t_sh *shell, t_ast_node *node);

// export utils
void	swap_values(t_var *a, t_var *b);
t_var	*copy_env(t_sh *shell);
t_var	*var_exists(t_sh *shell, char *var_to_check);
void	print_sorted_env(t_sh *shell);
char	**ret_env_array(t_sh *shell);

// unset utils
void	remove_var(t_sh *shell, char *var_title);

#endif
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   shell.h                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fflamion <fflamion@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/06 22:13:29 by fflamion          #+#    #+#             */
/*   Updated: 2024/11/12 17:56:28 by fflamion         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef SHELL_H
# define SHELL_H

typedef struct s_var
{
	char	*title;
	char	*value;
	size_t	index;
}			t_var;

typedef struct s_shell
{
	int		exit_status;
	t_var	*env;
	char	**envp;
	size_t	env_size;
}			t_sh;

void		update_exit_status(t_sh *shell, int status);
void		initialize_shell(t_sh *shell, char **envp);
char		*get_env_value(t_sh *shell, char *var_name);
void		free_shell(t_sh *shell);
void		mod_var(t_sh *shell, char *var_title, char *var_value);
#endif
