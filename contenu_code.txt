/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parse_redir.c                               :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fflamion <fflamion@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/01 18:12:45 by fflamion          #+#    #+#             */
/*   Updated: 2024/11/05 10:16:10 by fflamion         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minishell.h"

int	is_valid_redir_argument(t_token *token)
{
	return (token && (token->type == TOKEN_ARGUMENT
			|| token->type == TOKEN_HEREDOC
			|| token->type == TOKEN_STRING
			|| token->prev->type == TOKEN_ARGUMENT));
}

int	is_redirection_token(t_token *token)
{
	return (token && (token->type == TOKEN_REDIRECTION_IN
			|| token->type == TOKEN_REDIRECTION_OUT
			|| token->type == TOKEN_APPEND || token->type == TOKEN_HEREDOC));
}

t_ast_node	*handle_redirection(t_token **curr_tok, t_sh *shell)
{
	t_ast_node	*redir_node;
	t_token		*token;

	token = *curr_tok;
	*curr_tok = (*curr_tok)->next;
	if (!*curr_tok || !is_valid_redir_argument(*curr_tok))
	{
		if (*curr_tok)
			printf("minishell: %s: Aucun fichier ou dossier de ce type\n",
				(*curr_tok)->value);
		else
			printf("minishell: Aucun fichier ou dossier de ce type\n");
		shell->exit_status = 1;
		return (NULL);
	}
	if (token->type == TOKEN_REDIRECTION_IN)
		redir_node = create_ast_node(AST_REDIRECTION_IN, shell);
	else if (token->type == TOKEN_REDIRECTION_OUT)
		redir_node = create_ast_node(AST_REDIRECTION_OUT, shell);
	else if (token->type == TOKEN_APPEND)
		redir_node = create_ast_node(AST_REDIRECTION_APPEND, shell);
	else
		redir_node = create_ast_node(AST_REDIRECTION_HEREDOC, shell);
	return (redir_node);
}

void	parse_redir(t_token **curr_tok, t_ast_node *cmd_node, t_sh *shell)
{
	t_ast_node	*redir_node;
	t_ast_node	*tmp;

	while (is_redirection_token(*curr_tok))
	{
		redir_node = handle_redirection(curr_tok, shell);
		if (!redir_node)
			return ;
		redir_node->filename = ft_strdup((*curr_tok)->value);
		*curr_tok = (*curr_tok)->next;
		if (!cmd_node->left)
			cmd_node->left = redir_node;
		else
		{
			tmp = cmd_node->left;
			while (tmp->left)
				tmp = tmp->left;
			tmp->left = redir_node;
		}
	}
}

// void	parse_redir(t_token **curr_tok, t_ast_node *cmd_node, t_sh *shell)
// {
// 	t_token		*token;
// 	t_ast_node	*redir_node;
// 	t_ast_node	*tmp;

// 	while (is_redirection_token(*curr_tok))
// 	{
// 		token = *curr_tok;
// 		*curr_tok = (*curr_tok)->next;
// 		if (!*curr_tok || ((*curr_tok)->type != TOKEN_ARGUMENT
// 				&& (*curr_tok)->type != TOKEN_HEREDOC
// 				&& (*curr_tok)->type != TOKEN_STRING
// 				&& (*curr_tok)->prev->type != TOKEN_ARGUMENT))
// 		{
// 			if (*curr_tok != NULL)
// 				printf("minishell: %s: Aucun fichier ou dossier de ce type\n",
// 					(*curr_tok)->value);
// 			else
// 				printf("minishell: Aucun fichier ou dossier de ce type\n");
// 			// TODO: je ne sais pas si on garde cette erreur
// 			shell->exit_status = 1;
// 			return ;
// 		}
// 		if (token->type == TOKEN_REDIRECTION_IN)
// 			redir_node = create_ast_node(AST_REDIRECTION_IN, shell);
// 		if (token->type == TOKEN_REDIRECTION_OUT)
// 			redir_node = create_ast_node(AST_REDIRECTION_OUT, shell);
// 		else if (token->type == TOKEN_APPEND)
// 			redir_node = create_ast_node(AST_REDIRECTION_APPEND, shell);
// 		else if (token->type == TOKEN_HEREDOC)
// 			redir_node = create_ast_node(AST_REDIRECTION_HEREDOC, shell);
// 		redir_node->filename = ft_strdup((*curr_tok)->value);
// 		*curr_tok = (*curr_tok)->next;
// 		if (!cmd_node->left)
// 			cmd_node->left = redir_node;
// 		else
// 		{
// 			tmp = cmd_node->left;
// 			while (tmp->left)
// 				tmp = tmp->left;
// 			tmp->left = redir_node;
// 		}
// 	}
// }
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parser.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fflamion <fflamion@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/01 18:12:45 by fflamion          #+#    #+#             */
/*   Updated: 2024/11/10 14:13:21 by fflamion         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minishell.h"

t_ast_node	*ast_parser(t_t_list *token_list, t_sh *shell)
{
	t_token		*current_token;
	t_ast_node	*ast_root;

	current_token = token_list->first;
	ast_root = parse_and_or_sequence(&current_token, shell);
	return (ast_root);
}

t_ast_node	*parse_and_or_sequence(t_token **current_token, t_sh *shell)
{
	t_ast_node	*left;
	t_ast_node	*node;
	t_token		*token;

	left = parse_pipeline(current_token, shell);
	while (*current_token && ((*current_token)->type == TOKEN_AND
			|| (*current_token)->type == TOKEN_OR))
	{
		token = *current_token;
		*current_token = (*current_token)->next;
		node = create_ast_node(AST_AND, shell);
		if (token->type == TOKEN_OR)
		{
			node->type = AST_OR;
		}
		node->left = left;
		node->right = parse_pipeline(current_token, shell);
		left = node;
	}
	return (left);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parse_pipeline.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fflamion <fflamion@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/01 18:12:45 by fflamion          #+#    #+#             */
/*   Updated: 2024/11/10 14:12:53 by fflamion         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minishell.h"

t_ast_node	*parse_parentheses(t_token **current_token, t_sh *shell)
{
	t_ast_node	*node;
	char		*token_value;

	if ((*current_token)->type == TOKEN_LPAREN)
	{
		*current_token = (*current_token)->next;
		node = parse_and_or_sequence(current_token, shell);
		if (!(*current_token) || (*current_token)->type != TOKEN_RPAREN)
		{
			if (*current_token)
				token_value = (*current_token)->value;
			else
				token_value = "newline";
			fprintf(stderr,
				"minishell: syntax error near unexpected token `%s'\n",
				token_value);
			return (NULL);
		}
		*current_token = (*current_token)->next;
		return (node);
	}
	return (parse_command(current_token, shell));
}

t_ast_node	*parse_pipeline(t_token **current_token, t_sh *shell)
{
	t_ast_node	*left;
	t_ast_node	*node;

	left = parse_parentheses(current_token, shell);
	while (*current_token && (*current_token)->type == TOKEN_PIPE)
	{
		*current_token = (*current_token)->next;
		node = create_ast_node(AST_PIPE, shell);
		node->left = left;
		node->right = parse_parentheses(current_token, shell);
		left = node;
	}
	return (left);
}

t_ast_node	*parse_command(t_token **current_token, t_sh *shell)
{
	t_ast_node	*node;

	node = create_ast_node(AST_COMMAND, shell);
	if ((*current_token)->type == TOKEN_HEREDOC)
	{
		add_argument(node, "test");
	}
	while (*current_token && is_redirection_token(*current_token))
	{
		parse_redir(current_token, node, shell);
	}
	while (*current_token && ((*current_token)->type == TOKEN_COMMAND
			|| (*current_token)->type == TOKEN_ARGUMENT
			|| (*current_token)->type == TOKEN_STRING
			|| (*current_token)->type == TOKEN_EXPAND))
	{
		add_argument(node, (*current_token)->value);
		*current_token = (*current_token)->next;
	}
	while (*current_token && is_redirection_token(*current_token))
	{
		parse_redir(current_token, node, shell);
	}
	return (node);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ast_list.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fflamion <fflamion@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/01 18:12:42 by fflamion          #+#    #+#             */
/*   Updated: 2024/11/10 16:13:34 by fflamion         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minishell.h"

t_ast_node	*create_ast_node(t_ast_node_type type, t_sh *shell)
{
	t_ast_node	*node;

	node = malloc(sizeof(t_ast_node));
	if (!node)
		return (NULL);
	node->type = type;
	node->argv = NULL;
	node->filename = NULL;
	node->left = NULL;
	node->right = NULL;
	node->shell = shell;
	return (node);
}

static char	**duplicate_argv(char **argv, int argc, char *argument)
{
	char	**new_argv;
	int		i;

	new_argv = malloc(sizeof(char *) * (argc + 2));
	if (!new_argv)
		return (NULL);
	i = 0;
	while (i < argc)
	{
		new_argv[i] = argv[i];
		i++;
	}
	new_argv[i] = ft_strdup(argument);
	new_argv[i + 1] = NULL;
	return (new_argv);
}

void	add_argument(t_ast_node *node, char *argument)
{
	char	**new_argv;
	int		argc;

	argc = 0;
	while (node->argv && node->argv[argc])
		argc++;
	new_argv = duplicate_argv(node->argv, argc, argument);
	if (!new_argv)
		return ;
	free(node->argv);
	node->argv = new_argv;
}

void	free_ast(t_ast_node *node)
{
	int	i;

	if (!node)
		return ;
	if (node->argv)
	{
		i = 0;
		while (node->argv[i])
		{
			free(node->argv[i]);
			i++;
		}
		free(node->argv);
	}
	if (node->filename)
		free(node->filename);
	free_ast(node->left);
	free_ast(node->right);
	free(node);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   print.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fflamion <fflamion@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/24 21:48:27 by fflamion          #+#    #+#             */
/*   Updated: 2024/11/05 19:07:18 by fflamion         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/debugger.h"
#include "../../include/minishell.h"

#define RESET "\033[0m"
#define RED "\033[31m"
#define GREEN "\033[32m"
#define Y "\033[33m"
#define BLUE "\033[34m"
#define MAGENTA "\033[35m"
#define CYAN "\033[36m"
#define WHITE "\033[37m"

void	print_token_type(t_token_type type)
{
	int			index;
	const char	*color_code;
	const char	*type_name;

	index = get_token_index(type);
	color_code = get_color_code(index);
	type_name = get_type(index);
	printf("%s%s%s", color_code, type_name, RESET);
}

void	print_token_info(t_token *token, unsigned int index)
{
	printf(BLUE "Token %u:\n" RESET, index);
	printf("  " MAGENTA "Type   : " RESET);
	print_token_type(token->type);
	printf("\n  " MAGENTA "Value  : " RESET "\"%s\"\n", token->value);
	printf(CYAN "-----------------------------\n" RESET);
}

void	print_t_list(t_t_list *t_list)
{
	t_token			*token_cursor;
	unsigned int	index;

	printf(CYAN "\n==TOKEN LIST(" Y "%u" CYAN " tokens)==\n" RESET,
		t_list->size);
	token_cursor = t_list->first;
	index = 0;
	while (token_cursor)
	{
		print_token_info(token_cursor, index);
		token_cursor = token_cursor->next;
		index++;
	}
	printf(CYAN "== END OF TOKEN LIST ==\n\n" RESET);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_info.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fflamion <fflamion@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/03 19:01:31 by fflamion          #+#    #+#             */
/*   Updated: 2024/11/06 22:19:51 by fflamion         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/debugger.h"
#include "../../include/minishell.h"

#define RESET "\033[0m"
#define RED "\033[31m"
#define GREEN "\033[32m"
#define YELLOW "\033[33m"
#define BLUE "\033[34m"
#define MAGENTA "\033[35m"
#define CYAN "\033[36m"
#define WHITE "\033[37m"

int	get_token_index(t_token_type type)
{
	const t_token_type	token_types[] = {TOKEN_COMMAND, TOKEN_ARGUMENT,
		TOKEN_PIPE, TOKEN_REDIRECTION_IN, TOKEN_REDIRECTION_OUT,
		TOKEN_APPEND, TOKEN_HEREDOC, TOKEN_VARIABLE, TOKEN_STRING,
		TOKEN_AND, TOKEN_OR, TOKEN_EOF, TOKEN_WILDCARDS, TOKEN_EXPAND,
		TOKEN_INCONNU, TOKEN_LPAREN, TOKEN_RPAREN};
	int					i;

	i = 0;
	while (i < (int)(sizeof(token_types) / sizeof(token_types[0])))
	{
		if (type & token_types[i])
			return (i);
		i++;
	}
	return (-1);
}

const char	*get_color_code(int index)
{
	const char	*color_codes[] = {GREEN, GREEN, YELLOW, YELLOW, YELLOW, YELLOW,
		YELLOW, CYAN, CYAN, CYAN, CYAN, MAGENTA, MAGENTA, MAGENTA, RED,
		BLUE, BLUE};

	if (index >= 0 && index < (int)(sizeof(color_codes)
		/ sizeof(color_codes[0])))
		return (color_codes[index]);
	return (RESET);
}

const char	*get_type(int index)
{
	const char	*types[] = {"Command", "Argument", "Pipe", "Redirection In",
		"Redirection Out", "Append", "Heredoc", "Variable", "String", "And",
		"Or", "End of File", "Wildcard", "Expand", "Unknown token type",
		"Left Parenthesis", "Right Parenthesis"};

	if (index >= 0 && index < (int)(sizeof(types) / sizeof(types[0])))
		return (types[index]);
	return ("Unknown Type");
}

const char	*get_color(int level)
{
	const char	*colors[] = {RED, GREEN, YELLOW, BLUE, MAGENTA, CYAN, WHITE};

	return (colors[level % 7]);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   print1.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fflamion <fflamion@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/03 19:05:11 by fflamion          #+#    #+#             */
/*   Updated: 2024/11/10 14:14:28 by fflamion         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/debugger.h"
#include "../../include/minishell.h"

void	print_ast(t_ast_node *node, int level)
{
	if (!node)
		return ;
	print_indentation(level);
	print_node_info(node, level);
	if (node->left)
		print_ast(node->left, level + 1);
	if (node->right)
		print_ast(node->right, level + 1);
}

void	print_env_debug(char **envp)
{
	int	i;

	i = 0;
	while (envp[i])
	{
		printf("%s\n", envp[i]);
		i++;
	}
}

void	print_indentation(int level)
{
	int	i;

	i = 0;
	while (i < level)
	{
		printf("    ");
		i++;
	}
}

void	print_node_type(t_ast_node *node)
{
	if (node->type == AST_COMMAND)
		printf("COMMAND: ");
	else if (node->type == AST_PIPE)
		printf("PIPE\n");
	else if (node->type == AST_AND)
		printf("AND (&&)\n");
	else if (node->type == AST_OR)
		printf("OR (||)\n");
	else if (node->type == AST_REDIRECTION_IN)
		printf("REDIR_IN: <%s\n", node->filename);
	else if (node->type == AST_REDIRECTION_OUT)
		printf("REDIR_OUT: >%s\n", node->filename);
	else if (node->type == AST_REDIRECTION_APPEND)
		printf("REDIR_APPEND: >>%s\n", node->filename);
	else if (node->type == AST_REDIRECTION_HEREDOC)
		printf("HEREDOC: <<%s\n", node->filename);
}

void	print_node_info(t_ast_node *node, int level)
{
	const char	*color;
	int			i;

	color = get_color(level);
	printf("%s", color);
	print_node_type(node);
	if (node->type == AST_COMMAND && node->argv)
	{
		i = 0;
		while (node->argv[i])
		{
			printf("%s", node->argv[i]);
			if (node->argv[i + 1])
				printf(" ");
			i++;
		}
		printf("\n");
	}
	printf(RESET);
}

void	print_ast_node(t_ast_node *node)
{
	if (!node)
	{
		printf("Node is NULL\n");
		return ;
	}
	printf("Node type: %d\n", node->type);
	printf("Node argv: ");
	if (node->argv)
	{
		for (int i = 0; node->argv[i]; i++)
		{
			printf("%s ", node->argv[i]);
		}
		printf("\n");
	}
	else
	{
		printf("NULL\n");
	}
	printf("Node filename: %s\n", node->filename ? node->filename : "NULL");
	printf("Node left: %p\n", (void *)node->left);
	printf("Node right: %p\n", (void *)node->right);
	printf("Node shell: %p\n", (void *)node->shell);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   free.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fflamion <fflamion@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/06 22:22:16 by fflamion          #+#    #+#             */
/*   Updated: 2024/11/09 23:00:51 by fflamion         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minishell.h"

void	free_shell(t_sh *shell)
{
	size_t	i;

	i = 0;
	while (i < shell->env_size)
	{
		free(shell->env[i].title);
		i++;
	}
	free(shell->env);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   fun.c                                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fflamion <fflamion@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/05 06:29:51 by fflamion          #+#    #+#             */
/*   Updated: 2024/11/05 19:08:51 by fflamion         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minishell.h"

void	init_colors(t_colors *color_set)
{
	color_set->colors[0] = "\033[0;31m";
	color_set->colors[1] = "\033[1;31m";
	color_set->colors[2] = "\033[0;32m";
	color_set->colors[3] = "\033[1;32m";
	color_set->colors[4] = "\033[0;33m";
	color_set->colors[5] = "\033[1;33m";
	color_set->colors[6] = "\033[0;34m";
	color_set->colors[7] = "\033[1;34m";
	color_set->colors[8] = "\033[0;35m";
	color_set->colors[9] = "\033[1;35m";
	color_set->colors[10] = "\033[0;36m";
	color_set->colors[11] = "\033[1;36m";
	color_set->colors[12] = "\033[0;37m";
	color_set->colors[13] = "\033[1;37m";
	color_set->colors[14] = "\033[0;90m";
	color_set->colors[15] = "\033[1;90m";
	color_set->reset_color = "\033[0m";
	color_set->color_count = 16;
	color_set->index = 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   initShell.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fflamion <fflamion@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/26 10:23:12 by fflamion          #+#    #+#             */
/*   Updated: 2024/11/06 22:22:42 by fflamion         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minishell.h"

void	create_base_env(t_sh *shell)
{
	shell->env = malloc(sizeof(t_var) * 4);
	if (!shell->env)
		return ;
	shell->env[0].title = ft_strdup("PWD");
	shell->env[0].value = getcwd(NULL, 0);
	shell->env[1].title = ft_strdup("SHLVL");
	shell->env[1].value = ft_strdup("1");
	shell->env[2].title = ft_strdup("_");
	shell->env[2].value = ft_strdup("/usr/bin/env");
	shell->env[3].title = NULL;
	shell->env[3].value = NULL;
	shell->env_size = 4;
	return ;
}

void	parse_env(t_sh *shell, char **envp)
{
	char	*buffer;
	int		before_equal;
	size_t	i;
	size_t	y;

	i = 0;
	y = 0;
	while (envp[i++])
		;
	shell->env = malloc(sizeof(t_var) * (i + 1));
	shell->env_size = i;
	i = 0;
	while (envp[y])
	{
		before_equal = ft_strchr(envp[y], '=') - envp[y];
		buffer = malloc(before_equal + 1);
		ft_strlcpy(buffer, envp[y], before_equal + 1);
		shell->env[i].title = ft_strdup(buffer);
		shell->env[i].value = ft_strdup(envp[y] + before_equal + 1);
		y++;
		i++;
		free(buffer);
	}
	shell->env[i].title = NULL;
	shell->env[i].value = NULL;
}

void	initialize_shell(t_sh *shell, char **envp)
{
	if (!*envp)
		create_base_env(shell);
	else
		parse_env(shell, envp);
	shell->envp = envp;
	shell->exit_status = 0;
}

void	update_exit_status(t_sh *shell, int status)
{
	if (WIFEXITED(status))
		shell->exit_status = WEXITSTATUS(status);
	else
		shell->exit_status = 1;
}

char	*get_env_value(const char *name, char **envp)
{
	int		i;
	size_t	len;

	i = 0;
	len = ft_strlen(name);
	while (envp[i])
	{
		if (ft_strncmp(envp[i], name, len) == 0 && envp[i][len] == '=')
			return (&envp[i][len + 1]);
		i++;
	}
	return (NULL);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   T_ListUtils.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: nghaddar <nghaddar@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/26 19:27:26 by nghaddar          #+#    #+#             */
/*   Updated: 2024/10/26 20:37:51 by nghaddar         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minishell.h"

t_t_list	*init_t_list(void)
{
	t_t_list	*new_t_list;

	new_t_list = malloc(sizeof(t_t_list));
	if (!new_t_list)
		return (NULL);
	new_t_list->first = NULL;
	new_t_list->last = NULL;
	new_t_list->size = 0;
	return (new_t_list);
}

void	free_token_list(t_t_list *t_list_to_free)
{
	t_token	*token_cursor;
	t_token	*to_free;

	if (t_list_to_free)
	{
		token_cursor = t_list_to_free->first;
		while (token_cursor)
		{
			to_free = token_cursor;
			token_cursor = to_free->next;
			if (to_free->value)
				free(to_free->value);
			free(to_free);
		}
		free(t_list_to_free);
	}
}

t_token	*create_token(const char *value, t_token_type type)
{
	t_token	*new_token;

	new_token = malloc(sizeof(t_token));
	if (!new_token)
		return (NULL);
	new_token->next = NULL;
	new_token->prev = NULL;
	new_token->type = type;
	new_token->index = 0;
	new_token->value = ft_strdup(value);
	if (!new_token->value)
	{
		free(new_token);
		return (NULL);
	}
	return (new_token);
}

void	add_token(t_t_list *t_list, t_token *new_token)
{
	if (!t_list || !new_token)
		return ;
	if (!t_list->first)
	{
		new_token->index = 0;
		t_list->first = new_token;
		t_list->last = new_token;
	}
	else
	{
		new_token->index = t_list->last->index + 1;
		new_token->prev = t_list->last;
		new_token->next = NULL;
		t_list->last->next = new_token;
		t_list->last = new_token;
	}
	t_list->size++;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils2.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: nghaddar <nghaddar@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/24 17:09:54 by fflamion          #+#    #+#             */
/*   Updated: 2024/11/04 13:45:45 by nghaddar         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minishell.h"

void	h_cmd_arg(char *input, uint16_t *i, t_t_list *t_list, char **envp)
{
	char	buffer[256];
	int		j;

	j = 0;
	while (input[*i] && !ft_isspace(input[*i])
		&& input[*i] != '|' && input[*i] != '>'
		&& input[*i] != '<' && j < (int) sizeof(buffer) - 1
		&& input[*i] != '(' && input[*i] != ')')
	{
		buffer[j++] = input[(*i)++];
	}
	buffer[j] = '\0';
	if (command_exists(buffer, envp))
		add_token(t_list, create_token(buffer, TOKEN_COMMAND));
	else
		add_token(t_list, create_token(buffer, TOKEN_ARGUMENT));
}

void	handle_and(uint16_t *i, t_t_list *t_list)
{
	add_token(t_list, create_token("&&", TOKEN_AND));
	(*i) += 2;
}

void	handle_wildcards(uint16_t *i, t_t_list *t_list)
{
	add_token(t_list, create_token("*", TOKEN_WILDCARDS));
	(*i)++;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils4.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fflamion <fflamion@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/29 15:54:03 by fflamion          #+#    #+#             */
/*   Updated: 2024/10/31 11:50:58 by fflamion         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minishell.h"

void	handle_heredoc(t_token *heredoc_token, char *delimiter)
{
	int		fd;
	char	*line;

	fd = open("heredoc.txt", O_CREAT | O_WRONLY | O_TRUNC, 0644);
	if (fd == -1)
		return ;
	while (1)
	{
		line = readline("> ");
		if (!line || ft_strcmp(line, delimiter) == 0)
			break ;
		write(fd, line, ft_strlen(line));
		write(fd, "\n", 1);
		free(line);
	}
	free(line);
	close(fd);
	free(heredoc_token->value);
	heredoc_token->value = ft_strdup("heredoc.txt");
}

void	handle_inconnu(char *input, uint16_t *i, t_t_list *t_list)
{
	char	buffer[2];

	buffer[0] = input[*i];
	buffer[1] = '\0';
	add_token(t_list, create_token(buffer, TOKEN_INCONNU));
	(*i)++;
}

void	handle_builtin_command(char *input, uint16_t *i, t_t_list *t_list)
{
	char	buffer[256];
	int		j;

	j = 0;
	while (input[*i] && !ft_isspace(input[*i])
		&& input[*i] != '|' && input[*i] != '>'
		&& input[*i] != '<' && j < (int) sizeof(buffer) - 1)
	{
		buffer[j++] = input[(*i)++];
	}
	buffer[j] = '\0';
	add_token(t_list, create_token(buffer, TOKEN_COMMAND));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils3.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fflamion <fflamion@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/08 13:34:12 by fflamion          #+#    #+#             */
/*   Updated: 2024/11/08 13:34:14 by fflamion         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minishell.h"

void	handle_brace_expand(char *input, uint16_t *i, t_t_list *t_list)
{
	char	buffer[256];
	size_t	j;
	char	*word;

	j = 0;
	(*i)++;
	while (input[*i] && input[*i] != '}')
	{
		if (j < sizeof(buffer) - 1)
			buffer[j++] = input[*i];
		(*i)++;
	}
	if (input[*i] != '}')
	{
		fprintf(stderr, "Error: Missing closing brace\n");
		return ;
	}
	(*i)++;
	buffer[j] = '\0';
	word = ft_strtok(buffer, " ");
	while (word != NULL)
	{
		add_token(t_list, create_token(word, TOKEN_EXPAND));
		word = ft_strtok(NULL, " ");
	}
}

void	h_alnum_ex(char *input, uint16_t *i, t_t_list *token_list, char **envp)
{
	char			buffer[256];
	unsigned int	j;
	char			*value;

	j = 0;
	while (input[*i] && (ft_isalnum(input[*i]) || input[*i] == '_'))
	{
		if (j < sizeof(buffer) - 1)
			buffer[j++] = input[*i];
		(*i)++;
	}
	buffer[j] = '\0';
	value = get_env_value(buffer, envp);
	if (value)
		add_token(token_list, create_token((value), TOKEN_EXPAND));
	else
		add_token(token_list, create_token((""), TOKEN_EXPAND));
}

void	h_exp(char *input, uint16_t *i, t_t_list *t_list, t_sh *shell)
{
	char	*status;

	(*i)++;
	if (input[*i] == '?')
	{
		status = ft_itoa(shell->exit_status);
		add_token(t_list, create_token(status, TOKEN_EXPAND));
		free(status);
		(*i)++;
	}
	else if (input[*i] == '{')
		handle_brace_expand(input, i, t_list);
	else
		h_alnum_ex(input, i, t_list, shell->envp);
}

char	*parse_env_var(char *input, uint16_t *i, t_sh *shell)
{
	char	var_name[256];
	char	*env_value;
	size_t	var_len;

	var_len = 0;
	while (input[*i] && ft_isalnum(input[*i]) && var_len < sizeof(var_name) - 1)
	{
		var_name[var_len] = input[*i];
		var_len++;
		(*i)++;
	}
	var_name[var_len] = '\0';
	env_value = get_env_value(var_name, shell->envp);
	if (env_value)
		return (env_value);
	else
		return ("");
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   lexer.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fflamion <fflamion@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/24 13:09:04 by fflamion          #+#    #+#             */
/*   Updated: 2024/11/10 13:26:54 by fflamion         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minishell.h"

int	is_builtin_command(char *cmd)
{
	return (!ft_strcmp(cmd, "cd") || !ft_strcmp(cmd, "history")
		|| !ft_strcmp(cmd, "exit") || !ft_strcmp(cmd, "alias")
		|| !ft_strcmp(cmd, "export") || !ft_strcmp(cmd, "unset"));
}

bool	is_whitespace(char c, uint16_t *i)
{
	if (ft_isspace(c))
	{
		(*i)++;
		return (true);
	}
	return (false);
}

void	handle_token(char *input, uint16_t *i, t_t_list *t_list, t_sh *shell)
{
	if (input[*i] == '|')
		h_pipe(input, i, t_list);
	else if (input[*i] == '>')
		h_rout(input, i, t_list);
	else if (input[*i] == '<')
		h_rin(input, i, t_list);
	else if (input[*i] == '\'')
		h_s_q(input, i, t_list);
	else if (input[*i] == '\"')
		h_d_q(input, i, t_list, shell);
	else if (input[*i] == '&' && input[*i + 1] == '&')
		handle_and(i, t_list);
	else if (input[*i] == '*')
		handle_wildcards(i, t_list);
	else if (input[*i] == '$')
		h_exp(input, i, t_list, shell);
	else if (input[*i] == '(' || input[*i] == ')')
		h_par(input[*i], i, t_list);
	else if (ft_strchr("!@#%^&_=", input[*i]))
		handle_inconnu(input, i, t_list);
	else if (is_builtin_command(&input[*i]))
		handle_builtin_command(input, i, t_list);
	else
		h_cmd_arg(input, i, t_list, shell->envp);
}

t_t_list	*lexer(char *input, t_sh *shell)
{
	t_t_list	*t_list;
	uint16_t	i;

	i = 0;
	t_list = init_t_list();
	if (!t_list)
		return (NULL);
	while (input[i] && is_whitespace(input[i], &i))
		;
	if (input[i] == '\0')
		return (t_list);
	i = 0;
	while (input[i])
	{
		while (is_whitespace(input[i], &i))
			;
		if (input[i] == '\0')
			break ;
		handle_token(input, &i, t_list, shell);
	}
	return (t_list);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils1.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fflamion <fflamion@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/24 17:04:19 by fflamion          #+#    #+#             */
/*   Updated: 2024/11/10 16:27:27 by fflamion         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minishell.h"

void	h_pipe(char *input, uint16_t *i, t_t_list *t_list)
{
	if (input[*i + 1] == '|')
	{
		add_token(t_list, create_token("||", TOKEN_OR));
		(*i) += 2;
	}
	else
	{
		add_token(t_list, create_token("|", TOKEN_PIPE));
		(*i)++;
	}
}

void	h_rout(char *input, uint16_t *i, t_t_list *t_list)
{
	if (input[*i + 1] == '>')
	{
		add_token(t_list, create_token(">>", TOKEN_APPEND));
		(*i) += 2;
	}
	else
	{
		add_token(t_list, create_token(">", TOKEN_REDIRECTION_OUT));
		(*i)++;
	}
}

void h_rin(char *input, uint16_t *i, t_t_list *t_list)
{
    if (input[*i + 1] == '<')
    {
        add_token(t_list, create_token("<<", TOKEN_HEREDOC));
        (*i) += 2;
        // Ignore les espaces
        while (input[*i] && ft_isspace(input[*i]))
            (*i)++;
        // Prend le premier mot comme dÃ©limiteur
        char buffer[256];
        int j = 0;
        while (input[*i] && !ft_isspace(input[*i]) && j < 255)
            buffer[j++] = input[(*i)++];
        buffer[j] = '\0';
        if (j > 0)
            add_token(t_list, create_token(buffer, TOKEN_STRING));
    }
    else
    {
        add_token(t_list, create_token("<", TOKEN_REDIRECTION_IN));
        (*i)++;
    }
}

void	h_s_q(char *input, uint16_t *i, t_t_list *t_list)
{
	char		buffer[256];
	uint16_t	j;

	j = 0;
	(*i)++;
	while (input[*i] && input[*i] != '\'' && j < sizeof(buffer) - 1)
		buffer[j++] = input[(*i)++];
	buffer[j] = '\0';
	if (input[*i] == '\'')
	{
		add_token(t_list, create_token(buffer, TOKEN_STRING));
		(*i)++;
	}
	else
		fprintf(stderr, "Error: Missing closing single quote\n");
}

// void	h_d_q(char *input, uint16_t *i, t_t_list *t_list, t_sh *shell)
// {
// 	char	buffer[256];
// 	char	*env_value;
// 	size_t	j;

// 	j = 0;
// 	(*i)++;
// 	while (input[*i] && input[*i] != '\"')
// 	{
// 		if (input[*i] == '$' && input[*i + 1] == '?')
// 		{
// 			(*i) += 2;
// 			env_value = ft_itoa(shell->exit_status);
// 			while (*env_value && j < sizeof(buffer) - 1)
// 				buffer[j++] = *env_value++;
// 		}
// 		else if (input[*i] == '$')
// 		{
// 			(*i)++;
// 			env_value = parse_env_var(input, i, shell);
// 			while (*env_value && j < sizeof(buffer) - 1)
// 				buffer[j++] = *env_value++;
// 		}
// 		else if (j < sizeof(buffer) - 1)
// 			buffer[j++] = input[(*i)++];
// 	}
// 	buffer[j] = '\0';
// 	add_token(t_list, create_token(buffer, TOKEN_STRING));
// 	if (input[*i] == '\"')
// 		(*i)++;
// 	else
// 		printf("Error: Missing closing double quote\n");
// }
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils5.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fflamion <fflamion@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/03 16:40:08 by fflamion          #+#    #+#             */
/*   Updated: 2024/11/03 16:40:40 by fflamion         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minishell.h"

bool	check_path(char *path, char *command)
{
	char	*full_path;
	int		exists;

	full_path = ft_strjoin(path, "/");
	if (!full_path)
		return (false);
	full_path = ft_strjoin_free(full_path, command);
	if (!full_path)
		return (false);
	exists = (access(full_path, X_OK) == 0);
	free(full_path);
	return (exists);
}

bool	command_exists(char *command, char **envp)
{
	char	*path;
	char	**paths;
	int		i;
	bool	found;

	path = get_env_value("PATH", envp);
	if (!path)
		return (false);
	paths = ft_split(path, ':');
	if (!paths)
		return (false);
	i = 0;
	found = false;
	while (paths[i] && !found)
	{
		found = check_path(paths[i], command);
		i++;
	}
	ft_free_split(paths);
	return (found);
}

void	h_par(char c, uint16_t *i, t_t_list *t_list)
{
	if (c == '(')
		add_token(t_list, create_token("(", TOKEN_LPAREN));
	else if (c == ')')
		add_token(t_list, create_token(")", TOKEN_RPAREN));
	(*i)++;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils6.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fflamion <fflamion@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/10 13:33:17 by fflamion          #+#    #+#             */
/*   Updated: 2024/11/10 13:47:16 by fflamion         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minishell.h"

typedef struct s_process_data
{
	char		*input;
	t_t_list	*t_list;
	t_sh		*shell;
}				t_process_data;

static void	handle_exit_status(uint16_t *i, char *buffer, size_t *j,
		t_sh *shell)
{
	char	*env_value;
	char	*tmp;

	(*i) += 2;
	env_value = ft_itoa(shell->exit_status);
	if (!env_value)
		return ;
	tmp = env_value;
	while (*env_value && *j < 255)
		buffer[(*j)++] = *env_value++;
	free(tmp);
}

static void	handle_env_var(uint16_t *i, char *buffer, size_t *j,
		t_process_data *data)
{
	char	*env_value;

	(*i)++;
	env_value = parse_env_var(data->input, i, data->shell);
	if (!env_value)
		return ;
	while (env_value && *env_value && *j < 255)
		buffer[(*j)++] = *env_value++;
}

static void	process_double_quotes(uint16_t *i, char *buffer, size_t *j,
		t_process_data *data)
{
	while (data->input[*i] && data->input[*i] != '\"')
	{
		if (data->input[*i] == '$' && data->input[*i + 1] == '?')
			handle_exit_status(i, buffer, j, data->shell);
		else if (data->input[*i] == '$')
			handle_env_var(i, buffer, j, data);
		else if (*j < 255)
			buffer[(*j)++] = data->input[(*i)++];
	}
}

void	h_d_q(char *input, uint16_t *i, t_t_list *t_list, t_sh *shell)
{
	char			buffer[256];
	size_t			j;
	t_process_data	data;

	j = 0;
	data.input = input;
	data.t_list = t_list;
	data.shell = shell;
	(*i)++;
	process_double_quotes(i, buffer, &j, &data);
	buffer[j] = '\0';
	add_token(t_list, create_token(buffer, TOKEN_STRING));
	if (input[*i] == '\"')
		(*i)++;
	else
		ft_putstr_fd("Error: Missing closing double quote\n", 2);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parser.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fflamion <fflamion@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/29 14:48:46 by nghaddar          #+#    #+#             */
/*   Updated: 2024/11/10 13:54:47 by fflamion         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minishell.h"

int	verif_redir_in_out_set(t_token *redir_in_token)
{
	t_token_type	n_type;
	int				check_mask;

	if (!redir_in_token->next)
	{
		printf("minishell: syntax error near unexpected token `newline'\n");
		return (1);
	}
	n_type = redir_in_token->next->type;
	check_mask = TOKEN_STRING | TOKEN_COMMAND | TOKEN_EXPAND | TOKEN_ARGUMENT;
	if (!(n_type & check_mask))
	{
		if (redir_in_token->next)
			printf("minishell: syntax error near unexpected token `%s'\n",
				redir_in_token->next->value);
		else
			printf("minishell: syntax error near unexpected token `newline'\n");
		return (1);
	}
	return (0);
}

int	verif_operand_set(t_token *operand_token)
{
	t_token_type	p_type;
	int				check_mask;

	if (!operand_token->index || !operand_token->next)
	{
		printf("minishell: syntax error near unexpected token `%s'\n",
			operand_token->value);
		return (1);
	}
	p_type = operand_token->prev->type;
	check_mask = (TOKEN_ARGUMENT | TOKEN_STRING
			| TOKEN_WILDCARDS | TOKEN_EXPAND
			| TOKEN_COMMAND | TOKEN_RPAREN);
	if (!(p_type & check_mask))
	{
		printf("minishell: syntax error near unexpected token `%s'\n",
			operand_token->value);
		return (1);
	}
	return (0);
}

int	check_parentheses_balance(t_t_list *token_list)
{
	t_token	*current_token;
	int		balance;

	current_token = token_list->first;
	balance = 0;
	while (current_token)
	{
		if (current_token->type == TOKEN_LPAREN)
			balance++;
		else if (current_token->type == TOKEN_RPAREN)
			balance--;
		if (balance < 0)
		{
			printf("minishell: syntax error near unexpected token `%s'\n",
				current_token->value);
			return (1);
		}
		current_token = current_token->next;
	}
	if (balance != 0)
	{
		printf("minishell: syntax error: unmatched parentheses\n");
		return (1);
	}
	return (0);
}

int	check_token_type(t_token *token)
{
	int	status;

	status = 0;
	if (token->type == TOKEN_PIPE)
		status = verif_pipe(token);
	else if (token->type & (TOKEN_REDIRECTION_IN
			| TOKEN_HEREDOC | TOKEN_REDIRECTION_OUT
			| TOKEN_APPEND))
		status = verif_redir_in_out_set(token);
	else if (token->type & (TOKEN_AND | TOKEN_OR))
		status = verif_operand_set(token);
	else if (token->type == TOKEN_RPAREN)
		status = verif_rparen(token);
	return (status);
}

int	parser(t_t_list *token_list)
{
	t_token	*token_cursor;
	int		status;

	if (!token_list->size)
		return (1);
	token_cursor = token_list->first;
	status = 0;
	if (check_parentheses_balance(token_list))
		return (1);
	while (token_cursor)
	{
		status = check_token_type(token_cursor);
		if (status)
			return (status);
		token_cursor = token_cursor->next;
	}
	return (0);
}
// int	parser(t_t_list *token_list)
// {
// 	t_token	*token_cursor;
// 	int		status;

// 	if (!token_list->size)
// 		return (1);
// 	token_cursor = token_list->first;
// 	status = 0;
// 	if (check_parentheses_balance(token_list))
// 		return (1);
// 	while (token_cursor)
// 	{
// 		if (token_cursor->type == TOKEN_PIPE)
// 			status = verif_pipe(token_cursor);
// 		else if (token_cursor->type & (TOKEN_REDIRECTION_IN
		// | TOKEN_HEREDOC | TOKEN_REDIRECTION_OUT | TOKEN_APPEND))
// 			status = verif_redir_in_out_set(token_cursor);
// 		else if (token_cursor->type & (TOKEN_AND | TOKEN_OR))
// 			status = verif_operand_set(token_cursor);
// 		else if (token_cursor->type == TOKEN_RPAREN)
// 			status = verif_rparen(token_cursor);
// 		else if (token_cursor->type == TOKEN_INCONNU)
// 			status = verif_unknown(token_cursor);
// 		if (status)
// 			return (status);
// 		token_cursor = token_cursor->next;
// 	}
// 	return (0);
// }

// int	verif_unknown(t_token *unknown_token)
// {
// 	// printf("minishell: syntax error near unexpected token : `%s'\n",
// 	// 	unknown_token->value);
// 	return (1);
// }
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parser_utils.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fflamion <fflamion@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/03 16:46:24 by fflamion          #+#    #+#             */
/*   Updated: 2024/11/10 13:55:23 by fflamion         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minishell.h"

int	verif_pipe(t_token *pipe_token)
{
	t_token_type	p_type;
	int				check_mask;

	if (!pipe_token->index || !pipe_token->next)
	{
		printf("minishell: syntax error near unexpected token `|'\n");
		return (1);
	}
	p_type = pipe_token->prev->type;
	check_mask = (TOKEN_COMMAND
			| TOKEN_VARIABLE | TOKEN_STRING
			| TOKEN_ARGUMENT | TOKEN_EXPAND | TOKEN_RPAREN);
	if (!(p_type & check_mask))
	{
		printf("minishell: syntax error near unexpected token `|'\n");
		return (1);
	}
	return (0);
}

int	verif_rparen(t_token *par_token)
{
	if (par_token->prev->type == TOKEN_LPAREN)
	{
		printf("minishell: syntax error near unexpected token : `)'\n");
		return (1);
	}
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   signal.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: nghaddar <nghaddar@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/30 09:34:38 by fflamion          #+#    #+#             */
/*   Updated: 2024/11/09 15:49:09 by nghaddar         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minishell.h"

void	handle_sigint(int sig)
{
	if (sig == SIGINT)
	{
		write(1, "\n", 1);
		rl_on_new_line();
		// rl_replace_line("", 0);
		rl_redisplay();
	}
}

void	setup_signals(void)
{
	struct sigaction	sa;

	sa.sa_handler = &handle_sigint;
	sigemptyset(&sa.sa_mask);
	sa.sa_flags = SA_RESTART;
	sigaction(SIGINT, &sa, NULL);
	sa.sa_handler = SIG_IGN;
	sigaction(SIGQUIT, &sa, NULL);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   cd.c                                               :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fflamion <fflamion@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/24 14:29:27 by nghaddar          #+#    #+#             */
/*   Updated: 2024/11/06 22:17:29 by fflamion         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minishell.h"

int	ft_cd(char **args, t_sh *shell)
{
	char	*path;
	char	*old_pwd;
	char	current_pwd[PATH_MAX];

	if (!args[1])
	{
		path = get_env_value("HOME", shell->envp);
		if (!path)
			return (ft_putstr_fd("minishell: cd: HOME not set\n", 2), 1);
	}
	else
		path = args[1];
	old_pwd = getcwd(NULL, 0);
	if (!old_pwd)
		return (ft_putstr_fd("minishell: cd: error getting current directory\n",
				2), 1);
	if (chdir(path) == -1)
	{
		free(old_pwd);
		return (ft_putstr_fd("minishell: cd: ", 2), ft_putstr_fd(path, 2),
			ft_putstr_fd(": No such file or directory\n", 2), 1);
	}
	if (!getcwd(current_pwd, PATH_MAX))
	{
		free(old_pwd);
		return (ft_putstr_fd("minishell: cd: error getting new directory\n", 2),
			1);
	}
	free(old_pwd);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   exit.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fflamion <fflamion@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/06 15:26:42 by nghaddar          #+#    #+#             */
/*   Updated: 2024/11/06 21:53:32 by fflamion         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minishell.h"

int	ft_exit(char **args)
{
	long long	exit_code;
	char		*endptr;

	exit_code = 0;
	printf("exit\n");
	if (!args[1])
		exit(0);
	exit_code = strtoll(args[1], &endptr, 10);
	if (*endptr != '\0' || args[1][0] == '\0')
	{
		ft_putstr_fd("minishell: exit: ", 2);
		ft_putstr_fd(args[1], 2);
		ft_putstr_fd(": numeric argument required\n", 2);
		exit(255);
	}
	if (args[2])
	{
		ft_putstr_fd("minishell: exit: too many arguments\n", 2);
		return (1);
	}
	exit((unsigned char)exit_code);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   echo.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fflamion <fflamion@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/24 14:14:04 by nghaddar          #+#    #+#             */
/*   Updated: 2024/11/10 13:44:52 by fflamion         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minishell.h"

// int	ft_echo(char **args)
// {
// 	int		i;
// 	int		n_flag;
// 	char	*str;

// 	n_flag = 0;
// 	i = 1;
// 	while (args[i] && !ft_strncmp(args[i], "-n", 2))
// 	{
// 		str = args[i] + 1;
// 		while (*str == 'n')
// 			str++;
// 		if (*str == '\0')
// 			n_flag = 1;
// 		else
// 			break ;
// 		i++;
// 	}
// 	while (args[i])
// 	{
// 		write(1, args[i], ft_strlen(args[i]) + 1);
// 		if (args[i + 1])
// 			write(1, (const void *)' ', 2);
// 		i++;
// 	}
// 	if (!n_flag)
// 		write(1, (const void *)'\n', 2);
// 	return (0);
// }

int	is_n_option(const char *str)
{
	int	i;

	i = 2;
	if (str[0] != '-' || str[1] != 'n')
		return (0);
	while (str[i] == 'n')
		i++;
	return (str[i] == '\0');
}

char	**check_option(char **args, int *n_flag)
{
	*n_flag = 0;
	while (*args && is_n_option(*args))
	{
		*n_flag = 1;
		args++;
	}
	return (args);
}

int	ft_echo(char **args)
{
	int		n_flag;
	size_t	total_len;
	size_t	pos;
	size_t	len;
	char	**start;
	char	*buffer;
	char	**tmp;

	total_len = 0;
	pos = 0;
	if (!args || !*args)
		return (write(1, "\n", 1) != 1);
	args++;
	start = check_option(args, &n_flag);
	tmp = start;
	while (*tmp)
	{
		total_len += ft_strlen(*tmp);
		tmp++;
	}
	if (!n_flag)
		total_len++;
	buffer = malloc(total_len + 1);
	if (!buffer)
		return (1);
	while (*start)
	{
		len = ft_strlen(*start);
		ft_memcpy(buffer + pos, *start, len);
		pos += len;
		start++;
	}
	if (!n_flag)
		buffer[pos++] = '\n';
	buffer[pos] = '\0';
	write(1, buffer, pos);
	free(buffer);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   env.c                                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fflamion <fflamion@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/06 15:24:40 by nghaddar          #+#    #+#             */
/*   Updated: 2024/11/06 22:17:52 by fflamion         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minishell.h"

int	ft_env(t_sh *shell)
{
	size_t	i;

	i = 0;
	while (i < shell->env_size - 1) // -1 pour Ã©viter l'entrÃ©e NULL finale
	{
		if (shell->env[i].title && shell->env[i].value)
		{
			ft_putstr_fd(shell->env[i].title, STDOUT_FILENO);
			ft_putstr_fd("=", STDOUT_FILENO);
			ft_putstr_fd(shell->env[i].value, STDOUT_FILENO);
			ft_putstr_fd("\n", STDOUT_FILENO);
		}
			//printf("%s=%s\n", shell->env[i].title, shell->env[i].value);
		i++;
	}
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   pwd.c                                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fflamion <fflamion@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/06 15:20:10 by nghaddar          #+#    #+#             */
/*   Updated: 2024/11/06 21:52:39 by fflamion         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minishell.h"

int	ft_pwd(void)
{
	char	pwd[PATH_MAX];

	if (!getcwd(pwd, PATH_MAX))
		return (ft_putstr_fd("minishell: pwd: error getting current directory\n",
				2), 1);
	ft_putstr_fd(pwd, STDOUT_FILENO);
	ft_putstr_fd("\n", STDOUT_FILENO);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   unset.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: nghaddar <nghaddar@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/05 13:11:54 by nghaddar          #+#    #+#             */
/*   Updated: 2024/11/07 14:22:08 by nghaddar         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minishell.h"
#include "../../include/shell.h"

static int 	verify_arg(char *arg)
{
	if (!ft_isalpha(*arg))
		return (1);
	while (*arg)
	{
		if (!ft_isalnum(*arg))
			return (1);
		arg++;
	}
	return (0);
}

void 	remove_var(t_sh *shell, char *var_title)
{
	t_var	*new_env = NULL;
	size_t	i = 0;
	size_t	y = 0;

	new_env = malloc(sizeof(t_var) * shell->env_size);

	if (!new_env)
		return ;
	while (i < shell->env_size - 1)
	{
		if (ft_strcmp(shell->env[i].title, var_title))
		{
			new_env[y].title = ft_strdup(shell->env[i].title);
			new_env[y].value = ft_strdup(shell->env[i].value);
			y++;
		}
		free(shell->env[i].title);
		free(shell->env[i].value);
		i++;
	}
	shell->env_size--;
	free(shell->env);
	shell->env = new_env;
}

int		ft_unset(char **args, t_sh *shell)
{
	size_t i = 1;

	while (args[i])
	{
		if (verify_arg(args[i]))
		{
			printf("minishell: unset: `%s' not a valid identifier\n", args[i]);
			return (1);
		}
		if (!var_exists(shell, args[i])) //if variable does not exist, avoid useless copy
		{
			i++;
			continue;
		}
		remove_var(shell, args[i]);
		i++;
	}
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   export.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fflamion <fflamion@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/04 15:07:26 by nghaddar          #+#    #+#             */
/*   Updated: 2024/11/09 23:38:50 by fflamion         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minishell.h"
#include "../../include/shell.h"

void	print_sorted_env(t_sh *shell)
{
	t_var	*env_copy;
	int		has_swapped;
	size_t	i;

	has_swapped = 1;
	i = 0;
	size_t env_size = shell->env_size - 1; // Adjusted for zero-based index
	env_copy = copy_env(shell);
	if (!env_copy)
		return ;
	while (has_swapped)
	{
		has_swapped = 0;
		while (i < env_size - 1)
		{
			if (ft_strcmp(env_copy[i].title, env_copy[i + 1].title) > 0)
			{
				swap_values(&env_copy[i], &env_copy[i + 1]);
				has_swapped = 1;
			}
			i++;
		}
		i = 0;
	}
	while (i < env_size)
	{
		printf("export %s=\"%s\"\n", env_copy[i].title, env_copy[i].value);
		i++;
	}
	i = 0;
	while (i < env_size)
	{
		free(env_copy[i].title);
		free(env_copy[i].value);
		i++;
	}
	free(env_copy);
}

void	mod_var(t_sh *shell, char *var_title, char *var_value)
{
	t_var	*existing_value;

	existing_value = var_exists(shell, var_title);
	free(existing_value->value);
	existing_value->value = ft_strdup(var_value);
}

void	add_var(t_sh *shell, char *var_title, char *var_value)
{
	t_var	*new_env;
	size_t	i;

	i = 0;
	new_env = malloc(sizeof(t_var) * shell->env_size + 1);
	if (!new_env)
		return ;
	while (i < shell->env_size - 1)
	{
		new_env[i].title = ft_strdup(shell->env[i].title);
		new_env[i].value = ft_strdup(shell->env[i].value);
		free(shell->env[i].title);
		free(shell->env[i].value);
		i++;
	}
	new_env[i].title = ft_strdup(var_title);
	new_env[i].value = ft_strdup(var_value);
	new_env[i + 1].title = NULL;
	new_env[i + 1].value = NULL;
	shell->env_size++;
	free(shell->env);
	shell->env = new_env;
}

static int	verify_arg(char *arg)
{
	size_t	i;
	char	**str_split;

	i = -1;
	str_split = NULL;
	str_split = ft_split(arg, '=');
	if (!str_split)
	{
		while (arg[++i])
		{
			if (!ft_isalnum(arg[i]))
			{
				printf("minishell: export: %s not a valid identifier\n", arg);
				return (1);
			}
		}
	}
	else
	{
		while (str_split[0][++i])
		{
			if (!ft_isalnum(str_split[0][i]))
			{
				printf("minishell: export: %s not a valid identifier\n", arg);
				free_split(str_split);
				return (1);
			}
		}
	}
	return (0);
}

int	ft_export(char **args, t_sh *shell)
{
	char	**split_str;
	int		status;
	size_t	i;

	split_str = NULL;
	status = 0;
	i = 1;
	if (!args[i])
		print_sorted_env(shell);
	while (args[i])
	{
		if (verify_arg(args[i]))
			return (1);
		split_str = ft_split(args[i], '=');
		if (!split_str[1])
		{
			ft_free_split(split_str);
			status = 0;
			break ;
		}
		if (var_exists(shell, split_str[0]))
		{
			mod_var(shell, split_str[0], split_str[1]);
		}
		else
			add_var(shell, split_str[0], split_str[1]);
		i++;
		free_split(split_str);
	}
	return (status);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   export_utils1.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fflamion <fflamion@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/05 13:43:12 by nghaddar          #+#    #+#             */
/*   Updated: 2024/11/09 23:38:10 by fflamion         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minishell.h"
#include "../../include/shell.h"

void	free_split(char **split_str)
{
	if (split_str)
	{
		if (split_str[0])
			free(split_str[0]);
		if (split_str[1])
			free(split_str[1]);
		free(split_str);
	}
}

void	swap_values(t_var *a, t_var *b)
{
	t_var	tmp;

	tmp.title = a->title;
	tmp.value = a->value;
	a->title = b->title;
	a->value = b->value;
	b->title = tmp.title;
	b->value = tmp.value;
}

t_var	*copy_env(t_sh *shell)
{
	t_var	*env_copy;
	size_t	i;

	i = 0;
	size_t env_size = shell->env_size - 1; // Adjusted for zero-based index
	env_copy = malloc(sizeof(t_var) * (env_size + 1));
	if (!env_copy)
		return (NULL);
	while (i < env_size)
	{
		env_copy[i].title = ft_strdup(shell->env[i].title);
		if (!env_copy[i].title)
			break ;
		env_copy[i].value = ft_strdup(shell->env[i].value);
		if (!env_copy[i].value)
		{
			free(env_copy[i].title);
			break ;
		}
		i++;
	}
	env_copy[i].title = NULL;
	env_copy[i].value = NULL;
	return (env_copy);
}

t_var	*var_exists(t_sh *shell, char *var_to_check)
{
	size_t	i;

	i = 0;
	while (i < shell->env_size - 1)
	{
		if (ft_strcmp(shell->env[i].title, var_to_check) == 0)
			return (&shell->env[i]);
		i++;
	}
	return (NULL);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   executor_utils2.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fflamion <fflamion@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/05 08:09:09 by fflamion          #+#    #+#             */
/*   Updated: 2024/11/05 19:17:35 by fflamion         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minishell.h"

void	set_s_h(struct sigaction *sa, int signum, void (*handler)(int))
{
	sa->sa_handler = handler;
	sigemptyset(&sa->sa_mask);
	sa->sa_flags = 0;
	sigaction(signum, sa, NULL);
}

void	save_og_s(struct sigaction *orig_int, struct sigaction *orig_quit)
{
	sigaction(SIGINT, NULL, orig_int);
	sigaction(SIGQUIT, NULL, orig_quit);
}

void	res_sig(struct sigaction *orig_int, struct sigaction *orig_quit)
{
	sigaction(SIGINT, orig_int, NULL);
	sigaction(SIGQUIT, orig_quit, NULL);
}

void	set_signals_for_parent(struct sigaction *sa_ignore)
{
	set_s_h(sa_ignore, SIGINT, SIG_IGN);
	set_s_h(sa_ignore, SIGQUIT, SIG_IGN);
}

void	set_signals_for_child(struct sigaction *sa_default)
{
	set_s_h(sa_default, SIGINT, SIG_DFL);
	set_s_h(sa_default, SIGQUIT, SIG_DFL);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   executor_utils3.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fflamion <fflamion@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/05 08:12:14 by fflamion          #+#    #+#             */
/*   Updated: 2024/11/10 14:34:34 by fflamion         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minishell.h"

int	w_c(pid_t pid, t_sh *shell, struct sigaction *orig_int,
		struct sigaction *orig_quit)
{
	int					status;
	struct sigaction	sa_ignore;

	set_signals_for_parent(&sa_ignore);
	waitpid(pid, &status, 0);
	update_exit_status(shell, status);
	res_sig(orig_int, orig_quit);
	if (WIFSIGNALED(status) && WTERMSIG(status) == SIGINT)
		write(1, "\n", 1);
	return (shell->exit_status);
}

void	handle_exec_error(t_ast_node *node)
{
	ft_putstr_fd("minishell: ", 2);
	ft_putstr_fd(node->argv[0], 2);
	if (errno == ENOENT)
	{
		ft_putstr_fd(": command not found\n", 2);
		exit(127);
	}
	ft_putstr_fd(": ", 2);
	ft_putstr_fd(strerror(errno), 2);
	ft_putstr_fd("\n", 2);
	exit(126);
}

void	execute_child(t_ast_node *node, struct sigaction *sa_default)
{
	set_signals_for_child(sa_default);
	handle_redirections(node);
	if (execvp(node->argv[0], node->argv) == -1)
		handle_exec_error(node);
}

pid_t	create_child_process(t_ast_node *node)
{
	pid_t				pid;
	struct sigaction	sa_default;

	pid = fork();
	if (pid == 0)
		execute_child(node, &sa_default);
	return (pid);
}

// pid_t	create_child_process(t_ast_node *node)
// {
// 	pid_t				pid;
// 	struct sigaction	sa_default;

// 	pid = fork();
// 	if (pid == 0)
// 	{
// 		set_signals_for_child(&sa_default);
// 		handle_redirections(node);
// 		if (execvp(node->argv[0], node->argv) == -1)
// 		{
// 			if (errno == ENOENT)
// 			{
// 				ft_putstr_fd("minishell: ", 2);
// 				ft_putstr_fd(node->argv[0], 2);
// 				ft_putstr_fd(": command not found", 2);
// 				ft_putstr_fd("\n", 2);
// 				exit(127);
// 			}
// 			else
// 			{
// 				ft_putstr_fd("minishell: ", 2);
// 				ft_putstr_fd(node->argv[0], 2);
// 				ft_putstr_fd(": ", 2);
// 				ft_putstr_fd(strerror(errno), 2);
// 				ft_putstr_fd("\n", 2);
// 				exit(126);
// 			}
// 		}
// 	}
// 	return (pid);
// }
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   executor_utils4.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fflamion <fflamion@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/10 14:21:20 by fflamion          #+#    #+#             */
/*   Updated: 2024/11/10 14:26:50 by fflamion         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minishell.h"

static void	write_heredoc_content(int fd, char *delimiter)
{
	char	*line;

	while (1)
	{
		line = readline("> ");
		if (!line)
			break ;
		if (ft_strcmp(line, delimiter) == 0)
		{
			free(line);
			break ;
		}
		write(fd, line, ft_strlen(line));
		write(fd, "\n", 1);
		free(line);
	}
}

void	setup_heredoc_reading(void)
{
	int	fd;

	fd = open("/tmp/heredoc_tmp", O_RDONLY);
	if (fd == -1)
	{
		perror("minishell: heredoc");
		exit(EXIT_FAILURE);
	}
	dup2(fd, STDIN_FILENO);
	close(fd);
	unlink("/tmp/heredoc_tmp");
}

void	handle_redir_heredoc(t_ast_node *node)
{
	int	fd;

	fd = open("/tmp/heredoc_tmp", O_CREAT | O_WRONLY | O_TRUNC, 0644);
	if (fd == -1)
	{
		perror("minishell: heredoc");
		exit(EXIT_FAILURE);
	}
	write_heredoc_content(fd, node->filename);
	close(fd);
	setup_heredoc_reading();
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   executor.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fflamion <fflamion@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/01 18:12:34 by fflamion          #+#    #+#             */
/*   Updated: 2024/11/09 20:23:48 by fflamion         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minishell.h"

int	execute_ast(t_ast_node *node, t_sh *shell)
{
	if (!node)
		return (0);
	if (node->type == AST_COMMAND)
		return (execute_command_node(node, shell));
	else if (node->type == AST_PIPE)
		return (execute_pipe_node(node, shell));
	else if (node->type == AST_AND)
		return (execute_and_node(node, shell));
	else if (node->type == AST_OR)
		return (execute_or_node(node, shell));
	return (0);
}

static int	is_builtin(char *cmd)
{
	return (!ft_strcmp(cmd, "echo") || !ft_strcmp(cmd, "cd") || !ft_strcmp(cmd,
			"pwd") || !ft_strcmp(cmd, "export") || !ft_strcmp(cmd, "unset")
		|| !ft_strcmp(cmd, "env") || !ft_strcmp(cmd, "exit"));
}

static int	execute_builtin(t_ast_node *node, t_sh *shell)
{
	char	*cmd;

	cmd = node->argv[0];
	if (!ft_strcmp(cmd, "echo"))
		return (ft_echo(node->argv));
	if (!ft_strcmp(cmd, "cd"))
		return (ft_cd(node->argv, shell));
	if (!ft_strcmp(cmd, "pwd"))
		return (ft_pwd());
	if (!ft_strcmp(cmd, "export"))
		return (ft_export(node->argv, shell));
	if (!ft_strcmp(cmd, "unset"))
		return (ft_unset(node->argv, shell));
	if (!ft_strcmp(cmd, "env"))
		return (ft_env(shell));
	if (!ft_strcmp(cmd, "exit"))
		return (ft_exit(node->argv));
	return (1);
}

// int	execute_command_node(t_ast_node *node, t_sh *shell)
// {
// 	pid_t				pid;
// 	struct sigaction	orig_int;
// 	struct sigaction	orig_quit;
// 	int					status;
// 	char				*cmd;

// 	cmd = node->argv[0];
// 	if (ft_isdigit(cmd[0])) // On vÃ©rifie si le premier caractÃ¨re est un chiffre
// 	{
// 		ft_putstr_fd("minishell: ", 2);
// 		ft_putstr_fd(node->argv[0], 2);
// 		ft_putstr_fd(": command not found\n", 2);
// 		shell->exit_status = 127;
// 		return (127);
// 	}
// 	if (is_builtin(node->argv[0]))
// 	{
// 		status = execute_builtin(node, shell);
// 		shell->exit_status = status;
// 		return (status);
// 	}
// 	save_og_s(&orig_int, &orig_quit);
// 	pid = create_child_process(node);
// 	if (pid < 0)
// 	{
// 		perror("minishell");
// 		return (-1);
// 	}
// 	if (pid > 0)
// 		return (w_c(pid, shell, &orig_int, &orig_quit));
// 	return (0);
// }
int	execute_command_node(t_ast_node *node, t_sh *shell)
{
	int	original_stdin;
	int	original_stdout;
	int	status;
		pid_t pid;
		struct sigaction orig_int;
		struct sigaction orig_quit;

	if (is_builtin(node->argv[0]))
	{
		// Save original file descriptors
		original_stdin = dup(STDIN_FILENO);
		original_stdout = dup(STDOUT_FILENO);
		// Handle redirections
		handle_redirections(node);
		// Execute builtin
		status = execute_builtin(node, shell);
		// Restore original file descriptors
		dup2(original_stdin, STDIN_FILENO);
		dup2(original_stdout, STDOUT_FILENO);
		close(original_stdin);
		close(original_stdout);
		shell->exit_status = status;
		return (status);
	}
	else
	{
		// Existing code for external commands
		save_og_s(&orig_int, &orig_quit);
		pid = create_child_process(node);
		if (pid < 0)
		{
			perror("minishell");
			return (-1);
		}
		if (pid > 0)
			return (w_c(pid, shell, &orig_int, &orig_quit));
		return (0);
	}
}

int	execute_pipe_node(t_ast_node *node, t_sh *shell)
{
	int		pipefd[2];
	pid_t	pid_left;
	pid_t	pid_right;
	int		status;

	if (pipe(pipefd) == -1)
		return (perror("minishell"), -1);
	pid_left = fork();
	if (pid_left == 0)
	{
		dup2(pipefd[1], STDOUT_FILENO);
		close(pipefd[0]);
		close(pipefd[1]);
		execute_ast(node->left, shell);
		exit(shell->exit_status);
	}
	pid_right = fork();
	if (pid_right == 0)
	{
		dup2(pipefd[0], STDIN_FILENO);
		close(pipefd[0]);
		close(pipefd[1]);
		execute_ast(node->right, shell);
		exit(shell->exit_status);
	}
	close(pipefd[0]);
	close(pipefd[1]);
	waitpid(pid_left, &status, 0);
	waitpid(pid_right, &status, 0);
	update_exit_status(shell, status);
	return (shell->exit_status);
}

int	execute_and_node(t_ast_node *node, t_sh *shell)
{
	int	status;

	status = execute_ast(node->left, shell);
	shell->exit_status = status;
	if (status == 0)
		return (execute_ast(node->right, shell));
	return (status);
}

int	execute_or_node(t_ast_node *node, t_sh *shell)
{
	int	status;

	status = execute_ast(node->left, shell);
	shell->exit_status = status;
	if (status != 0)
		return (execute_ast(node->right, shell));
	return (status);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   executor_utils1.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fflamion <fflamion@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/03 16:53:15 by fflamion          #+#    #+#             */
/*   Updated: 2024/11/10 14:35:53 by fflamion         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minishell.h"

void	handle_redir_in(t_ast_node *node)
{
	int	fd;

	fd = open(node->filename, O_RDONLY);
	if (fd == -1)
	{
		perror("minishell");
		exit(EXIT_FAILURE);
	}
	dup2(fd, STDIN_FILENO);
	close(fd);
}

void	handle_redir_out(t_ast_node *node, int flags)
{
	int	fd;

	fd = open(node->filename, flags, 0644);
	if (fd == -1)
	{
		perror("minishell");
		exit(EXIT_FAILURE);
	}
	dup2(fd, STDOUT_FILENO);
	close(fd);
}

void	handle_redirections(t_ast_node *node)
{
	t_ast_node	*redir;

	redir = node->left;
	while (redir)
	{
		if (redir->type == AST_REDIRECTION_IN)
			handle_redir_in(redir);
		else if (redir->type == AST_REDIRECTION_OUT)
			handle_redir_out(redir, O_WRONLY | O_CREAT | O_TRUNC);
		else if (redir->type == AST_REDIRECTION_APPEND)
			handle_redir_out(redir, O_WRONLY | O_CREAT | O_APPEND);
		else if (redir->type == AST_REDIRECTION_HEREDOC)
			handle_redir_heredoc(redir);
		redir = redir->left;
	}
}
// void	handle_redir_heredoc(t_ast_node *node)
// {
// 	char	*line;
// 	int		fd;
// 	char	*delimiter;

// 	// CrÃ©er un fichier temporaire pour le heredoc
// 	fd = open("/tmp/heredoc_tmp", O_CREAT | O_WRONLY | O_TRUNC, 0644);
// 	if (fd == -1)
// 	{
// 		perror("minishell: heredoc");
// 		exit(EXIT_FAILURE);
// 	}
// 	delimiter = node->filename;
// 	while (1)
// 	{
// 		line = readline("> ");
// 		if (!line)
// 			break ;
// 		if (ft_strcmp(line, delimiter) == 0)
// 		{
// 			free(line);
// 			break ;
// 		}
// 		write(fd, line, ft_strlen(line));
// 		write(fd, "\n", 1);
// 		free(line);
// 	}
// 	close(fd);
// 	// RÃ©ouvrir le fichier pour la lecture
// 	fd = open("/tmp/heredoc_tmp", O_RDONLY);
// 	if (fd == -1)
// 	{
// 		perror("minishell: heredoc");
// 		exit(EXIT_FAILURE);
// 	}
// 	dup2(fd, STDIN_FILENO);
// 	close(fd);
// 	unlink("/tmp/heredoc_tmp"); // Supprimer le fichier temporaire
// }/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   minishell.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fflamion <fflamion@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/23 09:47:28 by fflamion          #+#    #+#             */
/*   Updated: 2024/11/10 16:21:18 by fflamion         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../include/minishell.h"

int	process_input(char *input, t_sh *shell)
{
	t_t_list	*t_list;
	t_ast_node	*ast_root;

	t_list = lexer(input, shell);
	if (!t_list)
		return (1);
	print_t_list(t_list);
	if (parser(t_list))
	{
		free_token_list(t_list);
		return (0);
	}
	ast_root = ast_parser(t_list, shell);
	execute_ast(ast_root, shell);
	free_ast(ast_root);
	free_token_list(t_list);
	return (0);
}

void	main_loop(t_sh *shell)
{
	char			*input;
	static t_colors	color_set;

	if (color_set.color_count == 0)
		init_colors(&color_set);
	setup_signals();
	while (1)
	{
		printf("%s", color_set.colors[color_set.index]);
		input = readline("minishell> ");
		printf("%s", color_set.reset_color);
		color_set.index = (color_set.index + 1) % color_set.color_count;
		if (!input)
		{
			printf("exit\n");
			break ;
		}
		if (*input)
		{
			add_history(input);
			if (process_input(input, shell))
				break ;
		}
		free(input);
	}
}

int	main(void)
{
	t_sh		shell;
	extern char	**environ;

	initialize_shell(&shell, environ);
	main_loop(&shell);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   funny.h                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fflamion <fflamion@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/05 06:32:06 by fflamion          #+#    #+#             */
/*   Updated: 2024/11/05 18:44:28 by fflamion         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef FUNNY_H
# define FUNNY_H

typedef struct s_colors
{
	const char	*colors[17];
	const char	*reset_color;
	int			color_count;
	int			index;
}	t_colors;

void	init_colors(t_colors *color_set);

#endif/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   signal.h                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fflamion <fflamion@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/30 09:05:55 by fflamion          #+#    #+#             */
/*   Updated: 2024/11/05 18:44:59 by fflamion         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef SIGNAL_H
# define SIGNAL_H

void	setup_signals(void);

#endif/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   debugger.h                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fflamion <fflamion@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/24 21:57:07 by fflamion          #+#    #+#             */
/*   Updated: 2024/11/10 16:12:35 by fflamion         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef DEBUGGER_H
# define DEBUGGER_H

# include "minishell.h"
# include "ast.h"

# define RESET "\033[0m"
# define RED "\033[31m"
# define GREEN "\033[32m"
# define YELLOW "\033[33m"
# define BLUE "\033[34m"
# define MAGENTA "\033[35m"
# define CYAN "\033[36m"
# define WHITE "\033[37m"

void		print_t_list(t_t_list *list);
void		print_token_info(t_token *token, unsigned int index);
void		print_token_type(t_token_type type);

// get_info
const char	*get_type(int index);
const char	*get_color_code(int index);
int			get_token_index(t_token_type type);
const char	*get_color(int level);

// print
void		print_ast(t_ast_node *node, int level);
void		print_node_info(t_ast_node *node, int level);
void		print_node_type(t_ast_node *node);
void		print_indentation(int level);
void		print_env_debug(char **envp);
void		print_env_debug(char **envp);
void	    print_ast_node(t_ast_node *node);

#endif
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   minishell.h                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fflamion <fflamion@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/23 09:50:53 by fflamion          #+#    #+#             */
/*   Updated: 2024/11/06 22:27:44 by fflamion         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef MINISHELL_H
# define MINISHELL_H

# include <unistd.h>
# include <stdlib.h>
# include <stdio.h>
# include <limits.h>
# include <stdint.h>
# include <sys/wait.h>
# include <sys/types.h>
# include <dirent.h>
# include <stdbool.h>
# include <fcntl.h>
# include <errno.h>
# include <signal.h>
# include <readline/readline.h>
# include <readline/history.h>

# include "../libft/includes/libft.h"
# include "shell.h"
# include "funny.h"
# include "lexer.h"
# include "parser.h"
# include "builtins.h"
# include "debugger.h"
# include "signal.h"
# include "ast.h"

#endif/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ast.h                                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fflamion <fflamion@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/01 12:36:31 by fflamion          #+#    #+#             */
/*   Updated: 2024/11/07 17:55:54 by fflamion         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef AST_H
# define AST_H

# include "debugger.h"
# include "lexer.h"

typedef enum e_ast_node_type
{
	AST_COMMAND,
	AST_PIPE,
	AST_AND,
	AST_OR,
	AST_REDIRECTION_IN,
	AST_REDIRECTION_OUT,
	AST_REDIRECTION_APPEND,
	AST_REDIRECTION_HEREDOC
}						t_ast_node_type;

typedef struct s_ast_node
{
	t_ast_node_type		type;
	char				**argv;
	char				*filename;
	struct s_ast_node	*left;
	struct s_ast_node	*right;
	t_sh				*shell;
}						t_ast_node;

// ast_list
t_ast_node				*create_ast_node(t_ast_node_type type, t_sh *shell);
void					add_argument(t_ast_node *node, char *argument);
void					free_ast(t_ast_node *node);

// parser
t_ast_node				*ast_parser(t_t_list *token_list, t_sh *shell);
t_ast_node				*parse_parentheses(t_token **current_token,
							t_sh *shell);
t_ast_node				*parse_command(t_token **current_token, t_sh *shell);
t_ast_node				*parse_pipeline(t_token **current_token, t_sh *shell);
t_ast_node				*parse_and_or_sequence(t_token **current_token,
							t_sh *shell);

// parse_redir
void					parse_redir(t_token **curr_t, t_ast_node *cmd_node,
							t_sh *sh);
int						is_redirection_token(t_token *token);

// parse_pipeline
t_ast_node				*parse_pipeline(t_token **current_token, t_sh *shell);
t_ast_node				*parse_parentheses(t_token **current_token,
							t_sh *shell);

// execution
int						execute_ast(t_ast_node *node, t_sh *shell);
int						execute_command_node(t_ast_node *node, t_sh *shell);
int						execute_pipe_node(t_ast_node *node, t_sh *shell);
int						execute_and_node(t_ast_node *node, t_sh *shell);
int						execute_or_node(t_ast_node *node, t_sh *shell);

// executor_utils1
void					handle_redir_in(t_ast_node *node);
void					handle_redir_out(t_ast_node *node, int flags);
void					handle_redirections(t_ast_node *node);
void					handle_redir_heredoc(t_ast_node *node);

// executor_utils2
void					set_s_h(struct sigaction *sa, int signum,
							void (*handler)(int));
void					save_og_s(struct sigaction *orig_int,
							struct sigaction *orig_quit);
void					res_sig(struct sigaction *orig_int,
							struct sigaction *orig_quit);
void					set_signals_for_parent(struct sigaction *sa_ignore);
void					set_signals_for_child(struct sigaction *sa_default);

// executor_utils3
int						w_c(pid_t p, t_sh *s, struct sigaction *b,
							struct sigaction *a);
pid_t					create_child_process(t_ast_node *node);

#endif
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   builtins.h                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: nghaddar <nghaddar@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/06 20:04:50 by fflamion          #+#    #+#             */
/*   Updated: 2024/11/07 14:22:01 by nghaddar         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef BUILTINS_H
# define BUILTINS_H

# include "shell.h"
# include <limits.h>

// utils
t_var	*copy_env(t_sh *shell);

int		ft_echo(char **args);
int		ft_cd(char **args, t_sh *shell);
int		ft_pwd(void);
int		ft_export(char **args, t_sh *shell);
int		ft_unset(char **args, t_sh *shell);
int		ft_env(t_sh *shell);
int		ft_exit(char **args);

// export utils
void	free_split(char **split_str);
void	swap_values(t_var *a, t_var *b);
t_var	*copy_env(t_sh *shell);
t_var	*var_exists(t_sh *shell, char *var_to_check);

// unset utils
void	remove_var(t_sh *shell, char *var_title);

#endif
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parser.h                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: nghaddar <nghaddar@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/29 14:43:43 by nghaddar          #+#    #+#             */
/*   Updated: 2024/11/09 15:02:04 by nghaddar         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef PARSER_H
# define PARSER_H

# include "lexer.h"

int		parser(t_t_list *token_list);

//utils
int		verif_pipe(t_token *pipe_token);
int		verif_rparen(t_token *par_token);

#endif
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   lexer.h                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fflamion <fflamion@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/10/24 13:09:54 by fflamion          #+#    #+#             */
/*   Updated: 2024/11/05 19:19:44 by fflamion         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef LEXER_H
# define LEXER_H

# include "minishell.h"

typedef enum e_token_type
{
	TOKEN_COMMAND = (1 << 0),
	TOKEN_ARGUMENT = (1 << 1),
	TOKEN_PIPE = (1 << 2),
	TOKEN_REDIRECTION_IN = (1 << 3),
	TOKEN_REDIRECTION_OUT = (1 << 4),
	TOKEN_APPEND = (1 << 5),
	TOKEN_HEREDOC = (1 << 6),
	TOKEN_VARIABLE = (1 << 7),
	TOKEN_STRING = (1 << 8),
	TOKEN_AND = (1 << 9),
	TOKEN_OR = (1 << 10),
	TOKEN_EOF = (1 << 11),
	TOKEN_WILDCARDS = (1 << 12),
	TOKEN_EXPAND = (1 << 13),
	TOKEN_INCONNU = (1 << 14),
	TOKEN_LPAREN = (1 << 15),
	TOKEN_RPAREN = (1 << 16),
}	t_token_type;

typedef struct s_token
{
	t_token_type		type;
	char				*value;
	uint16_t			index;
	struct s_token		*next;
	struct s_token		*prev;
}	t_token;

typedef struct s_token_list
{
	struct s_token	*first;
	struct s_token	*last;
	unsigned int	size;
}	t_t_list;

// T_List & token utils
t_t_list	*init_t_list(void);
void		free_token_list(t_t_list *t_list);
t_token		*create_token(const char *value, t_token_type type);
void		add_token(t_t_list *t_list, t_token *new_token);

t_t_list	*lexer(char *input, t_sh *shell);

// lexer utils1
void		h_pipe(char *input, uint16_t *i, t_t_list *t_list);
void		h_rout(char *input, uint16_t *i, t_t_list *t_list);
void		h_rin(char *input, uint16_t *i, t_t_list *t_list);
void		h_s_q(char *input, uint16_t *i, t_t_list *t_list);
void		h_d_q(char *input, uint16_t *i, t_t_list *t_list, t_sh *shell);

// lexer utils2
void		h_cmd_arg(char *input, uint16_t *i, t_t_list *t_list, char **invp);
void		handle_and(uint16_t *i, t_t_list *t_list);
void		handle_wildcards(uint16_t *i, t_t_list *t_list);

// lexer utils3
void		h_exp(char *input, uint16_t *i, t_t_list *t_list, t_sh *shell);
char		*parse_env_var(char *input, uint16_t *i, t_sh *shell);

// lexer utils4
void		handle_heredoc(t_token *heredoc_token, char *delimiter);
void		handle_inconnu(char *input, uint16_t *i, t_t_list *t_list);
void		handle_builtin_command(char *input, uint16_t *i, t_t_list *t_list);

// lexer utils5
bool		command_exists(char *command, char **envp);
void		h_par(char c, uint16_t *i, t_t_list *t_list);

#endif
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   shell.h                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: fflamion <fflamion@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/06 22:13:29 by fflamion          #+#    #+#             */
/*   Updated: 2024/11/06 22:13:35 by fflamion         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef SHELL_H
# define SHELL_H

typedef struct s_var
{
	char	*title;
	char	*value;
	size_t	index;
}			t_var;

typedef struct s_shell
{
	int		exit_status;
	t_var	*env;
	char	**envp;
	size_t	env_size;
}			t_sh;

void		update_exit_status(t_sh *shell, int status);
void		initialize_shell(t_sh *shell, char **envp);
char		*get_env_value(const char *name, char **envp);
void		free_shell(t_sh *shell);
#endif
